// Keep document header lines together!
// Certain attributes must be defined here to work correctly.
// https://docs.asciidoctor.org/asciidoc/latest/document/header
:doctitle: Ion 1.0 Denotational Semantics
:author: Todd V. Jonker
:email: jonker@amazon.com
// Document header ends at first blank line.

// TODO This is generating invalid DocBook: no <year> just <holder>
:copyright: 2023 Amazon.com Inc. or Affiliates (“Amazon”)
:doctype: article
:stem: latexmath

// Now custom attributes and styles.
:modeltex: ../build/ion-model.tex

include::styles.adoc[]


== Reading the Math

Our denotational model is expressed in terms of lambda calculus, and the
functions below use pretty-printed forms of numerous lambda calculus patterns.
This section introduces the primary domains and notations used by the model.

We use three fundamental domains, representing the primitive types.

[{denotation}]
++++
include::{modeltex}[tag=B]
\newline
include::{modeltex}[tag=I]
\newline
include::{modeltex}[tag=Unicode]
++++

Domain stem:[\mbox{\bf B}] has two values, stem:[\mbox{\bf true}] and
stem:[\mbox{\bf false}].
We test boolean values with a function _if_(_c_, _d_, _e_) that we pretty-print
as:

[{denotation}]
++++
\mbox{{\bf if} {\it c}\:{\bf then}\:{\it d}\:{\bf else}\:{\it e} {\bf endif}}
++++

We write **D**{asterisk} to mean the domain of sequences of **D**.
We pretty-print such values between angle brackets
stem:[\langle...\rangle].  For example,
stem:[\langle\mbox{\bf true}, \mbox{\bf false}\rangle \in \mbox{\bf B}^{\ast}].
We concatenate sequences with stem:[\S]; to push the element _d_ onto the front
of sequence stem:[d^{\ast}] we can write stem:[\langle d \rangle\S d^{\ast}].
To extract the stem:[i^{th}] element of sequence
stem:[d^{\ast} = \langle e_1, e_2, ..., e_n\rangle] we write
stem:[d^{\ast}\!\downarrow_{i} = e_i].
To discard the first _i_ elements of a sequence, we write
stem:[d^{\ast}\!\dagger i = \langle e_{i+1}, ..., e_n\rangle].
Finally, write stem:[\#d^{\ast}] to mean the number of items in stem:[d^{\ast}].

We write stem:[\mbox{\bf Sum} = \mbox{\bf D} + \mbox{\bf E}] to mean the
disjoint sum of domains **D** and **E**: every element of **Sum** is an element
of either **D** or **E**.
Elements of sum domains are effectively "`tagged`", so we know which component
domain they come from, and we can project or "`lower`" a value
stem:[v \in \mbox{\bf Sum}] back there via stem:[v\mid_{\mbox{\tiny\bf D}}],
assuming stem:[v \in \mbox{\bf D}].
Conversely, we can inject or "lift`" a component value into **Sum** using the
function stem:[\mbox{\it{in}\small \mbox{\bf Sum}}(\mbox{\it v\/})],
assuming stem:[v \in \mbox{\bf D} \vee v \in \mbox{\bf E}].

We write stem:[\mbox{\bf Prod} = \mbox{\bf D} \times \mbox{\bf E}] to mean the
Cartesian product of **D** and **E**. These are tuples containing first some
stem:[d \in \mbox{\bf D}] and then some stem:[e \in \mbox{\bf E}].
To extract elements from a tuple we can overload the stem:[\downarrow]
operator, so that when stem:[p \in \mbox{\bf Prod}] we have
stem:[p \downarrow_{1} \in \mbox{\bf D}] and
stem:[p \downarrow_{2} \in \mbox{\bf E}].


== Understanding the Denotation

At a high level, the goal of this model is to define how an Ion processor turns
"`raw values`" into "`application values`".  Raw values are fresh off the parser,
without any interpretation of symbol tables or translation of SIDs into text.
The IonJava library calls these "`system values`", and here we model them via
the domain **RValue**, which we'll define later.
We likewise model application values via the domain **Value**.

Ion gives special treatment to top-level values: IVMs and encoding directives
do not exist below top level.
We model an Ion document or datastream as a sequence of these top-level raw
values:

[{denotation}]
++++
include::{modeltex}[tag=TRValue]
\newline
include::{modeltex}[tag=IVM]
\newline
include::{modeltex}[tag=Ion1_0]
++++

The **TRValue** domain indicates that the (raw) top-level contains raw values and
IVMs.
**Ion1_0** is a singleton domain containing only the opaque constant
__ION_1_0__, and **IVM** is an extensible union of it with future IVMs.

Our goal then is to implement the following function:

// TODO Generate these function signatures.
[{denotation}]
++++
\mbox{\it expand} : \mbox{\bf TRValue*} \times \mbox{\bf Catalog} \rightarrow \mbox{\bf Value*}
++++

That is, given a sequence of raw top-level values and a catalog (that is, a set
of shared symbol tables), we produce a sequence of application values.


=== The Ion Data Model

Before we get into the mechanics of expansion, we need to define the data model
that flows through that process.


==== Safe Values

We'll start defining our data model with the easy cases: data types that cannot
contain SIDS and therefore don't require expansion.
For the moment, we are ignoring Ion annotations; we'll handle them elsewhere in
the domain model.

[{denotation}]
++++
include::{modeltex}[tag=DotNull]
\newline
include::{modeltex}[tag=NullNull]
\newline
include::{modeltex}[tag=Boolean]
\newline
include::{modeltex}[tag=Int]
\newline
include::{modeltex}[tag=String]
++++

The singleton domain **DotNull** contains only an opaque constant `DOTNULL`
that we use as a sentinel for the various typed nulls.  Such a thing is the only
option for the **NullNull** domain, where it denotes `null.null`.  The domains
**Boolean**, **Int**, and **String** simply combine the obvious primitive
domains with the possibility of null.

While we use a single sentinel value for all nulls, they are still
strongly-typed in the data model, since the sentinel is "`wrapped`" by an
appropriate domain denoting the data type.
For example, if we have a value _v_ such that
stem:[v \in \mbox{\bf Boolean} \wedge v \in \mbox{\bf DotNull}]
then we know that _v_ denotes `null.bool`.

In order to streamline some of the denotational functions, we'll group these
together into a common domain:

[{denotation}]
++++
include::{modeltex}[tag=SafeVal]
++++

Whereas the data types collected under **SafeVal** are modeled identically in
the raw and application layers, the remaining types must distinguish them.

NOTE: This denotation currently doesn't cover Ion's decimal, float, timestamp,
blob, and clob types.  If it did, they would be part of **SafeVal**,
with little effect on the remainder of the model.


==== Symbols

Symbols form the core of this denotation, which would be trivial if we didn't
need to expand SIDs into their text.
The following domains define their meaning:

[{denotation}]
++++
include::{modeltex}[tag=RSymTok]
\newline
include::{modeltex}[tag=SymTok]
\newline
include::{modeltex}[tag=Sym0]
++++

The on-the-wire representation of a symbol is denoted by a _raw symbol token_
**RSymTok** which is either a Unicode string or an integer SID.
After expansion, we get a non-raw **SymTok**, where a SID isn't possible,
but we can still get `$0`.
To express that, we use a singleton domain **Sym0** containing only an opaque
constant named `SYM0`.

Symbol tokens are used to define annotations, field names, and symbol values.
The latter are denoted as follows, where the value is either a symbol token or
`null.symbol`.

[{denotation}]
++++
include::{modeltex}[tag=RSymbol]
\newline
include::{modeltex}[tag=Symbol]
++++

To support our ability to match annotations and locate struct fields, we define
a couple helper functions.

[{denotation}]
++++
include::{modeltex}[tag=SymTok_matches]
\newline\newline
include::{modeltex}[tag=Symbol_matches]
++++

_SymTok_matches_ is straightforward: if the given **SymTok** is **Unicode** then
we lower into that domain and compare with the argument.
Otherwise, the token must be **Sym0**, so we return **false**.

_Symbol_matches_ similarly checks whether the **Symbol** is a **SymTok** (as
opposed to **DotNull**) before calling _SymTok_matches_.


==== Lists

Now that we've defined all of Ion's scalar types, we need to address containers.
Because these types can include symbols, we need both raw and non-raw domains.

Lists are simple to define: they are just sequences of values, or null.

[{denotation}]
++++
include::{modeltex}[tag=RList]
\newline
include::{modeltex}[tag=List]
++++

Here we introduce recursion into the domain model by using the (forthcoming)
aggregate domains covering all Ion values in both the raw and non-raw layers.

We'll eventually need to extract the sequence of values inside a list, so let's
create a little accessor function to make the math more clear:

[{denotation}]
++++
include::{modeltex}[tag=List_elts]
++++

NOTE: This denotation currently doesn't cover Ion S-expressions; they would work
identically to lists.


==== Structs

The domain model for structs is not much more complicated.

[{denotation}]
++++
include::{modeltex}[tag=RField]
\newline
include::{modeltex}[tag=RStruct]
\newline
include::{modeltex}[tag=Field]
\newline
include::{modeltex}[tag=Struct]
++++

This shouldn't be surprising: a struct is either null or a set of fields,
and a field is a tuple with a symbol token and a value.

IMPORTANT: This model is subtly incorrect, since its fields are ordered within a
struct.  Modeling unordered collections in lambda calculus is quite tricky, so
for now we'll settle for this defective approach.

As before, we introduce some helper notation to deconstruct fields:

[{denotation}]
++++
include::{modeltex}[tag=RField_name]
\newline
include::{modeltex}[tag=RField_value]
\newline
include::{modeltex}[tag=Field_name]
\newline
include::{modeltex}[tag=Field_value]
++++

To get data out of a struct by field name, we need a lookup function:

[{denotation}]
++++
include::{modeltex}[tag=Struct_get]
++++

This defines a local recursive function _seek_ which walks the struct's
**Field**{asterisk} to accumulate a **Value**{asterisk}.
To perform the recursion, we remove the first of the current fields via
stem:[f^{\ast}\dagger 1], invoke _seek_, and call the results stem:[v^\ast].
If the current field's name matches _u_ we prepend (stem:[\S]) its value
onto the recursive results.

That function returns the values of all fields with the given name, but it turns
out that the Ion processor never accepts more than one.
Here's a sibling function that signals an error when the lookup is ambiguous:

[{denotation}]
++++
include::{modeltex}[tag=Struct_get1]
++++

Note that this still returns a **Value**{asterisk} but the sequence always has
zero or one elements.


==== Annotated Values

Having defined all concrete types in the Ion data model, we can model their
union, thus representing all Ion data.  This is where we'll attach annotations
to content.

[{denotation}]
++++
include::{modeltex}[tag=RContent]
\newline
include::{modeltex}[tag=RValue]
\newline
include::{modeltex}[tag=Content]
\newline
include::{modeltex}[tag=Value]
++++

Formally, a values consists of its sequence of annotations, which are symbol
tokens, and its content, which is the union of all data types.

As usual, accessor functions:

[{denotation}]
++++
include::{modeltex}[tag=RValue_annots]
\newline
include::{modeltex}[tag=RValue_content]
\newline
include::{modeltex}[tag=Value_annots]
\newline
include::{modeltex}[tag=Value_content]
++++

And finally, a couple of bespoke predicates that we'll use to detect and compile
local symbol tables.

[{denotation}]
++++
include::{modeltex}[tag=Value_has_first_annot]
\newline\newline
include::{modeltex}[tag=Value_is_symbol_matching]
++++

// TODO LST, Environment, and lst lookup
// TODO Expansion and continuations
// TODO SSTs and Catalogs

// TODO Document known issues


== The (Practically) Complete Denotation

[{denotation}]
++++
include::{modeltex}[]
++++
