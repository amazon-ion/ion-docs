// Keep document header lines together!
// Certain attributes must be defined here to work correctly.
// https://docs.asciidoctor.org/asciidoc/latest/document/header
:doctitle: Ion 1.0 Denotational Semantics
:author: Todd V. Jonker
:email: jonker@amazon.com
// Document header ends at first blank line.

// TODO This is generating invalid DocBook: no <year> just <holder>
:copyright: 2023 Amazon.com Inc. or Affiliates (“Amazon”)
:doctype: article
:stem: latexmath

// Now custom attributes and styles.
:modeltex: ../build/ion-model.tex

include::styles.adoc[]


== Reading the Math

Our denotational model is expressed in terms of lambda calculus, and the
functions below use pretty-printed forms of numerous lambda calculus patterns.
This section introduces the primary domains and notations used by the model.

We use three fundamental domains, representing the primitive types.

[{denotation}]
++++
include::{modeltex}[tag=B]
\newline
include::{modeltex}[tag=I]
\newline
include::{modeltex}[tag=Unicode]
++++

Domain stem:[\mbox{\bf B}] has two values, stem:[\mbox{\bf true}] and
stem:[\mbox{\bf false}].
We test boolean values with a function _if_(_c_, _d_, _e_) that we pretty-print
as:

[{denotation}]
++++
\mbox{{\bf if} {\it c}\:{\bf then}\:{\it d}\:{\bf else}\:{\it e} {\bf endif}}
++++

We write **D**{asterisk} to mean the domain of sequences of **D**.
We pretty-print such values between angle brackets
stem:[\langle...\rangle].  For example,
stem:[\langle\mbox{\bf true}, \mbox{\bf false}\rangle \in \mbox{\bf B}^{\ast}].
We concatenate sequences with stem:[\S]; to push the element _d_ onto the front
of sequence stem:[d^{\ast}] we can write stem:[\langle d \rangle\S d^{\ast}].
To extract the stem:[i^{th}] element of sequence
stem:[d^{\ast} = \langle e_1, e_2, ..., e_n\rangle] we write
stem:[d^{\ast}\!\downarrow_{i} = e_i].
To discard the first _i_ elements of a sequence, we write
stem:[d^{\ast}\!\dagger i = \langle e_{i+1}, ..., e_n\rangle].
Finally, write stem:[\#d^{\ast}] to mean the number of items in stem:[d^{\ast}].

We write stem:[\mbox{\bf Sum} = \mbox{\bf D} + \mbox{\bf E}] to mean the
disjoint sum of domains **D** and **E**: every element of **Sum** is an element
of either **D** or **E**.
Elements of sum domains are effectively "`tagged`", so we know which component
domain they come from, and we can project or "`lower`" a value
stem:[v \in \mbox{\bf Sum}] back there via stem:[v\mid_{\mbox{\tiny\bf D}}],
assuming stem:[v \in \mbox{\bf D}].
Conversely, we can inject or "lift`" a component value into **Sum** using the
function stem:[\mbox{\it{in}\small \mbox{\bf Sum}}(\mbox{\it v\/})],
assuming stem:[v \in \mbox{\bf D} \vee v \in \mbox{\bf E}].

We write stem:[\mbox{\bf Prod} = \mbox{\bf D} \times \mbox{\bf E}] to mean the
Cartesian product of **D** and **E**. These are tuples containing first some
stem:[d \in \mbox{\bf D}] and then some stem:[e \in \mbox{\bf E}].
To extract elements from a tuple we can overload the stem:[\downarrow]
operator, so that when stem:[p \in \mbox{\bf Prod}] we have
stem:[p \downarrow_{1} \in \mbox{\bf D}] and
stem:[p \downarrow_{2} \in \mbox{\bf E}].


== Understanding the Denotation

At a high level, the goal of this model is to define how an Ion processor turns
"`raw values`" into "`application values`".  Raw values are fresh off the parser,
without any interpretation of symbol tables or translation of SIDs into text.
The IonJava library calls these "`system values`", and here we model them via
the domain **RValue**, which we'll define later.
We likewise model application values via the domain **Value**.

Ion gives special treatment to top-level values: IVMs and encoding directives
do not exist below top level.
We model an Ion document or datastream as a sequence of these top-level raw
values:

[{denotation}]
++++
include::{modeltex}[tag=TRValue]
\newline
include::{modeltex}[tag=IVM]
\newline
include::{modeltex}[tag=Ion1_0]
++++

The **TRValue** domain indicates that the (raw) top-level contains raw values and
IVMs.
**Ion1_0** is a singleton domain containing only the opaque constant
__ION_1_0__, and **IVM** is an extensible union of it with future IVMs.

Our goal then is to implement the following function:

// TODO Generate these function signatures.
[{denotation}]
++++
\mbox{\it expand} : \mbox{\bf TRValue*} \times \mbox{\bf Catalog} \rightarrow \mbox{\bf Value*}
++++

That is, given a sequence of raw top-level values and a catalog (that is, a set
of shared symbol tables), we produce a sequence of application values.


=== The Ion Data Model

Before we get into the mechanics of expansion, we need to define the data model
that flows through that process.


==== Safe Values

We'll start defining our data model with the easy cases: data types that cannot
contain SIDS and therefore don't require expansion.
For the moment, we are ignoring Ion annotations; we'll handle them elsewhere in
the domain model.

[{denotation}]
++++
include::{modeltex}[tag=DotNull]
\newline
include::{modeltex}[tag=NullNull]
\newline
include::{modeltex}[tag=Boolean]
\newline
include::{modeltex}[tag=Int]
\newline
include::{modeltex}[tag=String]
++++

The singleton domain **DotNull** contains only an opaque constant `DOTNULL`
that we use as a sentinel for the various typed nulls.  Such a thing is the only
option for the **NullNull** domain, where it denotes `null.null`.  The domains
**Boolean**, **Int**, and **String** simply combine the obvious primitive
domains with the possibility of null.

While we use a single sentinel value for all nulls, they are still
strongly-typed in the data model, since the sentinel is "`wrapped`" by an
appropriate domain denoting the data type.
For example, if we have a value _v_ such that
stem:[v \in \mbox{\bf Boolean} \wedge v \in \mbox{\bf DotNull}]
then we know that _v_ denotes `null.bool`.

In order to streamline some of the denotational functions, we'll group these
together into a common domain:

[{denotation}]
++++
include::{modeltex}[tag=SafeVal]
++++

Whereas the data types collected under **SafeVal** are modeled identically in
the raw and application layers, the remaining types must distinguish them.

NOTE: This denotation currently doesn't cover Ion's decimal, float, timestamp,
blob, and clob types.  If it did, they would be part of **SafeVal**,
with little effect on the remainder of the model.


==== Symbols

Symbols form the core of this denotation, which would be trivial if we didn't
need to expand SIDs into their text.
The following domains define their meaning:

[{denotation}]
++++
include::{modeltex}[tag=RSymTok]
\newline
include::{modeltex}[tag=SymTok]
\newline
include::{modeltex}[tag=Sym0]
++++

The on-the-wire representation of a symbol is denoted by a _raw symbol token_
**RSymTok** which is either a Unicode string or an integer SID.
After expansion, we get a non-raw **SymTok**, where a SID isn't possible,
but we can still get `$0`.
To express that, we use a singleton domain **Sym0** containing only an opaque
constant named `SYM0`.

Symbol tokens are used to define annotations, field names, and symbol values.
The latter are denoted as follows, where the value is either a symbol token or
`null.symbol`.

[{denotation}]
++++
include::{modeltex}[tag=RSymbol]
\newline
include::{modeltex}[tag=Symbol]
++++

To support our ability to match annotations and locate struct fields, we define
a couple helper functions.

[{denotation}]
++++
include::{modeltex}[tag=SymTok_matches]
\newline\newline
include::{modeltex}[tag=Symbol_matches]
++++

_SymTok_matches_ is straightforward: if the given **SymTok** is **Unicode** then
we lower into that domain and compare with the argument.
Otherwise, the token must be **Sym0**, so we return **false**.

_Symbol_matches_ similarly checks whether the **Symbol** is a **SymTok** (as
opposed to **DotNull**) before calling _SymTok_matches_.


==== Lists

Now that we've defined all of Ion's scalar types, we need to address containers.
Because these types can include symbols, we need both raw and non-raw domains.

Lists are simple to define: they are just sequences of values, or null.

[{denotation}]
++++
include::{modeltex}[tag=RList]
\newline
include::{modeltex}[tag=List]
++++

Here we introduce recursion into the domain model by using the (forthcoming)
aggregate domains covering all Ion values in both the raw and non-raw layers.

We'll eventually need to extract the sequence of values inside a list, so let's
create a little accessor function to make the math more clear:

[{denotation}]
++++
include::{modeltex}[tag=List_elts]
++++

NOTE: This denotation currently doesn't cover Ion S-expressions; they would work
identically to lists.


==== Structs

The domain model for structs is not much more complicated.

[{denotation}]
++++
include::{modeltex}[tag=RField]
\newline
include::{modeltex}[tag=RStruct]
\newline
include::{modeltex}[tag=Field]
\newline
include::{modeltex}[tag=Struct]
++++

This shouldn't be surprising: a struct is either null or a set of fields,
and a field is a tuple with a symbol token and a value.

IMPORTANT: This model is subtly incorrect, since its fields are ordered within a
struct.  Modeling unordered collections in lambda calculus is quite tricky, so
for now we'll settle for this defective approach.

As before, we introduce some helper notation to deconstruct fields:

[{denotation}]
++++
include::{modeltex}[tag=RField_name]
\newline
include::{modeltex}[tag=RField_value]
\newline
include::{modeltex}[tag=Field_name]
\newline
include::{modeltex}[tag=Field_value]
++++

To get data out of a struct by field name, we need a lookup function:

[{denotation}]
++++
include::{modeltex}[tag=Struct_get]
++++

This defines a local recursive function _seek_ which walks the struct's
**Field**{asterisk} to accumulate a **Value**{asterisk}.
To perform the recursion, we remove the first of the current fields via
stem:[f^{\ast}\dagger 1], invoke _seek_, and call the results stem:[v^\ast].
If the current field's name matches _u_ we prepend (stem:[\S]) its value
onto the recursive results.

That function returns the values of all fields with the given name, but it turns
out that the Ion processor never accepts more than one.
Here's a sibling function that signals an error when the lookup is ambiguous:

[{denotation}]
++++
include::{modeltex}[tag=Struct_get1]
++++

Note that this still returns a **Value**{asterisk} but the sequence always has
zero or one elements.


==== Annotated Values

Having defined all concrete types in the Ion data model, we can model their
union, thus representing all Ion data.  This is where we'll attach annotations
to content.

[{denotation}]
++++
include::{modeltex}[tag=RContent]
\newline
include::{modeltex}[tag=RValue]
\newline
include::{modeltex}[tag=Content]
\newline
include::{modeltex}[tag=Value]
++++

Formally, a values consists of its sequence of annotations, which are symbol
tokens, and its content, which is the union of all data types.

As usual, accessor functions:

[{denotation}]
++++
include::{modeltex}[tag=RValue_annots]
\newline
include::{modeltex}[tag=RValue_content]
\newline
include::{modeltex}[tag=Value_annots]
\newline
include::{modeltex}[tag=Value_content]
++++

And finally, a couple of bespoke predicates that we'll use to detect and compile
local symbol tables.

[{denotation}]
++++
include::{modeltex}[tag=Value_has_first_annot]
\newline\newline
include::{modeltex}[tag=Value_is_symbol_matching]
++++


=== The Encoding Environment

The top-level of an Ion document can contain __directives__ that are not part of
the application-facing data model.
Instead, directives affect the encoding of the data that follows.

Ion 1.0 has two kinds of directives: Ion version markers, which can only occur
at top-level, and `$ion_symbol_table::` structs, which are only treated as
directives at top-level.  We model these top-level-only features through a
top-level-only domain:

[{denotation}]
++++
include::{modeltex}[tag=TRValue]
++++

In other words, the top-level can contain any raw value, as well as IVMs.
There's no corresponding non-raw domain **TValue** since directives need to be
removed by the expansion function on the way to producing application data.

Directives effectively change the state of the decoder as it turns bytes on the
wire into application data.
We model this state, known as the __environment__, as follows:

[{denotation}]
++++
include::{modeltex}[tag=Environment]
\newline
include::{modeltex}[tag=Catalog]
\newline
include::{modeltex}[tag=LocalSymtab]
++++

The encoding environment is a tuple with three components.

  * The __catalog__ is a collection of shared symbol tables provided to the
expansion process.  The manner by which SSTs are collected into a catalog is
outside the scope of the Ion specification.
  * We track the current Ion version by storing an Ion Version Marker.  This is
how we select a system symbol table, and gives us a way to alter the expansion
process based on Ion version.
  * We model the local symbol table as a sequence of symbol tokens defining all
current SIDs, starting from zero.

Following our practice for tuples, we'll define environment accessor functions.
Following computer science tradition, we use the Greek letter rho (stem:[\rho])
as the variable denoting environments.

[{denotation}]
++++
include::{modeltex}[tag=Environment_cat]
\newline
include::{modeltex}[tag=Environment_ivm]
\newline
include::{modeltex}[tag=Environment_lst]
++++

Ion documents always start in 1.0 mode.  Here's how we construct an appropriate
environment, parameterized by the user-supplied catalog.

[{denotation}]
++++
include::{modeltex}[tag=initial_env]
++++


=== Symbol Token Expansion

We've now set enough context that we can implement the core of the expansion
process: replacing SIDs with text.  We introduce stem:[{\cal E}] as the base
name of our various expansion functions, adding the input type as a subscript.

[{denotation}]
++++
include::{modeltex}[tag=E_RSymTok]
++++

Expansion of a raw symbol token requires the current environment.
If the symbol token already contains Unicode text, we simply wrap it with a
**SymTok**. Otherwise, the token is an integer SID, so we extract it via
stem:[\mbox{\it s\/}\mid_{\mbox{\tiny \mbox{\bf I}}}] and then look it up in the
environment's LST.  That requires a range check, returning `$0` if the SID
exceeds the size of the local symbol table.

CAUTION: This algorithm is currently defective: Ion specifies that an
out-of-bounds SID must evoke an error and stop parsing. Proper modeling of such
failures is WIP.

To handle annotations, we'll need a recursive function expanding a sequence of
symbol tokens:

[{denotation}]
++++
include::{modeltex}[tag=E_RSymTok*]
++++


=== Non-Top Value Expansion

Now we can define how non-top raw values are expanded.
Expansion of a single **RValue** requires separate expansion of its annotations
and content, combining the results into a **Value**:

[{denotation}]
++++
include::{modeltex}[tag=E]
++++

We expand a sequence of **RValue**s by simple recursion:

[{denotation}]
++++
include::{modeltex}[tag=E*]
++++

To expand **RContent** we must perform a type-switch.
**SafeVal**s pass through easily by being re-wrapped as **Content**.
Anything else can contain symbol tokens to be expanded, and in each case we
downcast the content, call a type-specific function, then rewrap the result.

[{denotation}]
++++
include::{modeltex}[tag=E_RContent]
++++

Expanding **RSymbol** just requires distinguishing `symbol.null`:

[{denotation}]
++++
include::{modeltex}[tag=E_RSymbol]
++++

Expanding **RList** is similar, with recursion on its sequence of elements:

[{denotation}]
++++
include::{modeltex}[tag=E_RList]
++++

To handle **RStruct** with the same pattern, we'll add a helper to expand its
sequence of fields:

[{denotation}]
++++
include::{modeltex}[tag=E_RStruct]
++++

Field-sequence expansion takes a bit more work.  When the sequence is not empty,
we expand the field's name and value using the appropriately-typed variants of
stem:[{\cal E}].  We turn those into a field and prepend it onto the result of
(self-recursively) expanding the sequence's tail.

[{denotation}]
++++
include::{modeltex}[tag=E_RField*]
++++

At this point we have fully denoted the expansion of non-top-level raw values,
and can turn to the top level.



// TODO Expansion and continuations
// TODO SSTs and Catalogs
//  * Catalog cannot be affected by expansion
// TODO Document known issues


== The (Practically) Complete Denotation

[{denotation}]
++++
include::{modeltex}[]
++++
