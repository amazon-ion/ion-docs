// Keep document header lines together!
// Certain attributes must be defined here to work correctly.
// https://docs.asciidoctor.org/asciidoc/latest/document/header
:doctitle: Ion 1.0 Denotational Semantics
:author: Todd V. Jonker
:email: jonker@amazon.com
// Document header ends at first blank line.

// TODO This is generating invalid DocBook: no <year> just <holder>
:copyright: 2023 Amazon.com Inc. or Affiliates (“Amazon”)
:doctype: article
:stem: latexmath

// Now custom attributes and styles.
:modeltex: tex/ion-model.tex

include::styles.adoc[]


== Introduction

This document describes the _denotational semantics_ of the Ion data language,
mapping Ion syntax to typed _domains_ in lambda calculus and using mathematical
functions to define the meaning of the computational elements that translate
that syntax into application data.

Our primary goal is to illuminate and clarify the process of _expansion_ by
which certain Ion encoding artifacts are transformed to produce the user's data.
In Ion 1.0 these artifacts include version markers, local symbol table
directives, and symbol tokens.
Ion 1.1 introduces much more sophisticated encoding features--new directives,
modules, encoding expressions--and this document is intended to lay the
groundwork for a formal presentation of those features.

TIP: We assume a basic familiarity with lambda calculus, though not much more
than the ability to recognize that stem:[\lambda xy.\mbox{\it body}]
represents a function of two arguments.


=== A Primer

Lambda calculus is a mathematical formalism for computing that uses only
anonymous functions (i.e., abstractions or lambda), terms (i.e., variables),
and application (i.e., invocation of functions).
This minimal set of operations has been shown to be Turing complete and can
encode mathematical concepts such as Booleans and natural numbers (and the
operations on them).
It is similarly straightforward to model data types such as _sequences_ and
_tuples_ using lambda calculus.

With these primitives we define types of values over lambda calculus as a
_domain_.  For our purposes, a _domain_ can be thought of as a set of tagged
values, where each value knows what type it is.  This allows the math to be
strongly-typed, at the expense of some bookkeeping to convert values across
domains.


// == Reading the Math

// Our denotational model is expressed in terms of lambda calculus, and the
// functions below use pretty-printed forms of numerous lambda calculus patterns.
// This section introduces the primary domains and notations used by the model.

Our first fundamental domain stem:[\mbox{\bf B}] denotes Boolean values.
It has two elements, the constants *true* and *false*.
We test Boolean values with a function _if_(_b_, _d_, _e_), where
stem:[b \in \mbox{\bf B}], which we pretty-print as
stem:[
\mbox{{\bf if} {\it b}\:{\bf then}\:{\it d}\:{\bf else}\:{\it e} {\bf endif}}
].  We assume the presence of related Boolean operators _and_ (stem:[\wedge]),
_or_ (stem:[\vee]) and _not_ (stem:[\lnot]).

Our second fundamental domain, *I*, denotes integer values, which comes along
with the obvious arithmetic operators.

We write **D**{asterisk} to mean the domain of sequences of **D** and
pretty-print such values between angle brackets stem:[\langle...\rangle].
For example,
stem:[\langle\mbox{\bf true}, \mbox{\bf false}\rangle \in \mbox{\bf B}^{\ast}].
To make variable names somewhat self-describing, we use asterisks there too,
as in stem:[d^\ast \in \mbox{\bf D}^\ast].
We concatenate sequences with stem:[\S]; to push the element _d_ onto the front
of sequence stem:[d^{\ast}] we can write stem:[\langle d \rangle\S d^{\ast}].
To extract an individual element of sequence
stem:[d^{\ast} = \langle e_0, e_1, ..., e_n\rangle] we write
stem:[d^{\ast}\!\downarrow_{i} = e_i].
To discard the first _i_ elements of a sequence, we write
stem:[d^{\ast}\!\dagger i = \langle e_i, ..., e_n\rangle].
Finally, we write stem:[\#d^{\ast}] to mean the number of items in
stem:[d^{\ast}].

We write stem:[\mbox{\bf Sum} = \mbox{\bf D} + \mbox{\bf E}] to mean the
disjoint sum of domains **D** and **E**: every element of **Sum** is an element
of either **D** or **E**.
Elements of sum domains are effectively "`tagged`", so we know which component
domain they come from, and we can project or "`lower`" a value
stem:[v \in \mbox{\bf Sum}] back there via stem:[v\mid_{\mbox{\tiny\bf D}}],
assuming stem:[v \in \mbox{\bf D}].
Conversely, we can inject or "`lift`" a component value into **Sum** using the
function stem:[\mbox{\it{in}\small \mbox{\bf Sum}}(\mbox{\it v\/})],
assuming stem:[v \in \mbox{\bf D} \vee v \in \mbox{\bf E}].

We write stem:[\mbox{\bf Prod} = \mbox{\bf D} \times \mbox{\bf E}] to mean the
Cartesian product of **D** and **E**. These are tuples containing first some
stem:[d \in \mbox{\bf D}] and then some stem:[e \in \mbox{\bf E}].
To extract elements from a tuple we can overload the stem:[\downarrow]
operator, so that when stem:[p \in \mbox{\bf Prod}] we have
stem:[p \downarrow_{1} \in \mbox{\bf D}] and
stem:[p \downarrow_{2} \in \mbox{\bf E}].
To improve readability, our model generally introduces additional overloads
addressing tuple fields by name.

Perhaps stretching credibility, we assume another primitive domain, *Unicode*,
denoting Unicode strings.
While we have not explicitly modeled it as such, this is just a sequence of
Unicode code points, effectively **I**{asterisk}.


=== A Roadmap

At a high level, the goal of our model is to define how an Ion processor turns
"`raw values`" into "`application values`".  Raw values are fresh off the parser,
without any interpretation of directives or translation of SIDs into text.
Some Ion products and documents call these "`system values`", and here we model
them via the domain **RValue**, which we'll define later.
We likewise model fully-expanded application values via the domain **Value**.

Syntactically, IVMs are keywords/opcodes reserved only at top-level.
We model them as a tuple holding major and minor version numbers:

[{denotation}]
++++
include::{modeltex}[tag=IVM]
++++

To constrain where IVMs can appear in the data model, we define a separate
domain for top-level raw values:

[{denotation}]
++++
include::{modeltex}[tag=TRValue]
++++

This domain specifies that the (raw) top-level contains raw values and IVMs.
We model an Ion document or datastream as a sequence of these, namely
**TRValue**{asterisk}.

We can now clarify that our goal is to implement the following function:

// TODO Generate these function signatures.
[{denotation}]
++++
\mbox{\it expand} : \mbox{\bf TRValue*} \times \mbox{\bf Catalog} \rightarrow \mbox{\bf Value*}
++++

That is, given a sequence of raw top-level values and a catalog (a collection
of shared symbol tables), we produce a sequence of application values.

Here's how we'll reach that goal:

* xref:datamodel[xrefstyle=short] defines a number of domains that collectively
specify the Ion data model in both its raw (*RValue*) and application (*Value*)
forms.
Along the way, we'll ease into denotational functions by implementing some
useful operators over this data.

* xref:expansion[xrefstyle=short] visits each corner of the data model,
incrementally defining layers of functions that build up to _expand_.

* xref:symtabs[xrefstyle=short] specifies the handling of encoding directives,
then the far more complicated process of compiling local symbol tables.

* xref:issues[xrefstyle=short] documents the known defects with the model in its
current draft.


[#datamodel]
== The Ion Data Model

Before we get into the mechanics of expansion, we need to define the data model
that flows through that process.


=== Safe Values

TIP: We know that "`safe`" is not the best discriminator for this set of values.
Please suggest better alternatives!

We'll start defining our data model with the easy cases: data types that cannot
contain SIDS and therefore don't require expansion.
For the moment, we are ignoring Ion annotations; we'll handle them elsewhere in
the domain model.

[{denotation}]
++++
include::{modeltex}[tag=DotNull]
\newline
include::{modeltex}[tag=NullNull]
\newline
include::{modeltex}[tag=Boolean]
\newline
include::{modeltex}[tag=Int]
\newline
include::{modeltex}[tag=String]
++++

The singleton domain **DotNull** contains only an opaque constant `DOTNULL`
that we use as a sentinel for the various typed nulls.  Such a thing is the only
option for the **NullNull** domain, where it denotes `null.null`.  The domains
**Boolean**, **Int**, and **String** simply combine the obvious primitive
domains with the possibility of null.

While we use a single sentinel value for all nulls, they are still
strongly-typed in the data model, since the sentinel is "`wrapped`" by an
appropriate domain denoting the data type.
For example, if we have a value _v_ such that
stem:[v \in \mbox{\bf Boolean} \wedge v \in \mbox{\bf DotNull}]
then we know that _v_ denotes `null.bool`.

In order to streamline some of the denotational functions, we'll group these
together into a common domain:

[{denotation}]
++++
include::{modeltex}[tag=SafeVal]
++++

Whereas the data types collected under **SafeVal** are modeled identically in
the raw and application layers, the remaining types must distinguish them.

NOTE: This denotation currently doesn't cover Ion's decimal, float, timestamp,
blob, and clob types.  If it did, they would be part of **SafeVal**,
with little effect on the remainder of the model.


=== Symbols

Symbols form the core of this denotation, which would be trivial if we didn't
need to expand SIDs into their text.
The following domains define their meaning:

[{denotation}]
++++
include::{modeltex}[tag=RSymTok]
\newline
include::{modeltex}[tag=SymTok]
\newline
include::{modeltex}[tag=Sym0]
++++

The on-the-wire representation of a symbol is denoted by a _raw symbol token_
**RSymTok** which is either a Unicode string or an integer SID.
After expansion, we get a non-raw **SymTok**, where a SID isn't possible,
but we can still get `$0`.
To express that, we use a singleton domain **Sym0** containing only an opaque
constant named `SYM0`.

Symbol tokens are used to define annotations, field names, and symbol values.
The latter are denoted as follows, where the value is either a symbol token or
`null.symbol`.

[{denotation}]
++++
include::{modeltex}[tag=RSymbol]
\newline
include::{modeltex}[tag=Symbol]
++++

To support our ability to match annotations and locate struct fields, we define
a couple helper functions.

[{denotation}]
++++
include::{modeltex}[tag=SymTok_matches]
\newline\newline
include::{modeltex}[tag=Symbol_matches]
++++

_SymTok_matches_ is straightforward: if the given **SymTok** is **Unicode** then
we lower into that domain and compare with the argument.
Otherwise, the token must be **Sym0**, so we return **false**.

_Symbol_matches_ similarly checks whether the **Symbol** is a **SymTok** (as
opposed to **DotNull**) before calling _SymTok_matches_.


=== Lists

Now that we've defined all of Ion's scalar types, we need to address containers.
Because these types can include symbols, we need both raw and non-raw domains.

Lists are simple to define: they are just sequences of values, or null.

[{denotation}]
++++
include::{modeltex}[tag=RList]
\newline
include::{modeltex}[tag=List]
++++

Here we introduce recursion into the domain model by using the (forthcoming)
aggregate domains covering all Ion values in both the raw and non-raw layers.

We'll eventually need to extract the sequence of values inside a list, so let's
create a little accessor function to make the math more clear:

[{denotation}]
++++
include::{modeltex}[tag=List_elts]
++++

NOTE: This denotation currently doesn't cover Ion S-expressions; they would work
identically to lists.


=== Structs

The domain model for structs is not much more complicated.

[{denotation}]
++++
include::{modeltex}[tag=RField]
\newline
include::{modeltex}[tag=RStruct]
\newline
include::{modeltex}[tag=Field]
\newline
include::{modeltex}[tag=Struct]
++++

This shouldn't be surprising: a struct is either null or a set of fields,
and a field is a tuple with a symbol token and a value.

IMPORTANT: This model is subtly incorrect, since its fields are ordered within a
struct.  Modeling unordered collections in lambda calculus is quite tricky, so
for now we'll settle for this defective approach.

As before, we introduce some helper notation to deconstruct fields:

[{denotation}]
++++
include::{modeltex}[tag=RField_name]
\newline
include::{modeltex}[tag=RField_value]
\newline
include::{modeltex}[tag=Field_name]
\newline
include::{modeltex}[tag=Field_value]
++++

To get data out of a struct by field name, we need a lookup function:

[{denotation}]
++++
include::{modeltex}[tag=Struct_get]
++++

This defines a local recursive function _seek_ which walks the struct's
**Field**{asterisk} to accumulate a **Value**{asterisk}.
To perform the recursion, we remove the first of the current fields via
stem:[f^{\ast}\dagger 1], invoke _seek_, and call the results stem:[v^\ast].
If the current field's name matches _u_ we prepend (stem:[\S]) its value
onto the recursive results.

That function returns the values of all fields with the given name, but it turns
out that the Ion processor never accepts more than one.
Here's a sibling function that signals an error when the lookup is ambiguous:

[{denotation}]
++++
include::{modeltex}[tag=Struct_get1]
++++

Note that this still returns a **Value**{asterisk} but the sequence always has
zero or one elements.


=== Annotated Values

Having defined all concrete types in the Ion data model, we can model their
union, thus representing all Ion data.  This is where we'll attach annotations
to content.

[{denotation}]
++++
include::{modeltex}[tag=RContent]
\newline
include::{modeltex}[tag=RValue]
\newline
include::{modeltex}[tag=Content]
\newline
include::{modeltex}[tag=Value]
++++

Formally, a values consists of its sequence of annotations, which are symbol
tokens, and its content, which is the union of all data types.

As usual, accessor functions:

[{denotation}]
++++
include::{modeltex}[tag=RValue_annots]
\newline
include::{modeltex}[tag=RValue_content]
\newline
include::{modeltex}[tag=Value_annots]
\newline
include::{modeltex}[tag=Value_content]
++++

// TODO Move these down where they're needed.
And finally, a couple of bespoke predicates that we'll use to detect and compile
local symbol tables.

[{denotation}]
++++
include::{modeltex}[tag=Value_has_first_annot]
\newline\newline
include::{modeltex}[tag=Value_is_symbol_matching]
++++

This concludes our semantics of the raw and application-level data models.
These are the inputs and outputs, respectively, of the expansion process, which
we will now explore.


[#expansion]
== Expansion

Circling back a bit, remember that our goal is to define how Ion expands the raw
document data produced by its parser to eliminate encoding features such as
symbol IDs and produce the document's application-facing data.
We'll encapsulate that process in this function:

// TODO Generate these function signatures.
[{denotation}]
++++
\mbox{\it expand} : \mbox{\bf TRValue*} \times \mbox{\bf Catalog} \rightarrow \mbox{\bf Value*}
++++

To begin, let's consider the top-level structure of an Ion document.


=== The Encoding Environment

The top-level of an Ion document can contain __directives__ that are not part of
the application-facing data model.
Instead, directives affect the encoding of the data that follows.

Ion 1.0 has two kinds of directives: Ion version markers (IVMs) and local symbol
tables (LSTs).  Syntactically, IVMs are expressed through a dedicated keyword
(opcode in binary); in particular, they are not symbols.
Since we cannot express IVMs within *RValue*, we model these top-level-only
features through a top-level-only domain:

[{denotation}]
++++
include::{modeltex}[tag=TRValue]
++++

In other words, the top-level can contain any raw value, as well as IVMs.
There's no corresponding non-raw domain **TValue** since directives need to be
removed by the expansion function on the way to producing application data.

Directives effectively change the state of the decoder as it turns bytes on the
wire into application data.
We model this state, known as the __environment__, as follows:

[{denotation}]
++++
include::{modeltex}[tag=Environment]
\newline
include::{modeltex}[tag=Catalog]
++++

The encoding environment is a tuple with three components.

  * The __catalog__ is a collection of shared symbol tables provided to the
expansion process.  The manner by which SSTs are collected into a catalog is
outside the scope of the Ion specification.
  * We model the current Ion version as an Ion Version Marker.  This is used to
select a system symbol table, and gives us a way to alter the expansion
process based on Ion version.
  * We model the current symbol table as a sequence of symbol tokens defining
all current SIDs, starting from zero.

Following our practice for tuples, we'll define environment accessor functions.
Following computer science tradition, we use the Greek letter rho (stem:[\rho])
as the variable denoting environments.

[{denotation}]
++++
include::{modeltex}[tag=Environment_catalog]
\newline
include::{modeltex}[tag=Environment_IVM]
\newline
include::{modeltex}[tag=Environment_symbols]
++++


=== Symbol Token Expansion

We've now set enough context that we can implement the core of the expansion
process: replacing SIDs with text.  We introduce stem:[{\cal E}] as the base
name of our various expansion functions, adding the input type as a subscript.

[{denotation}]
++++
include::{modeltex}[tag=E_RSymTok]
++++

Expansion of a raw symbol token requires the current environment.
If the symbol token already contains Unicode text, we simply wrap it with a
**SymTok**. Otherwise, the token is an integer SID, so we extract it via
stem:[\mbox{\it s\/}\mid_{\mbox{\tiny \mbox{\bf I}}}] and then look it up in the
current symbol table.  That requires a range check, returning `$0` if the SID
exceeds the size of the current symbol table.

CAUTION: This algorithm is currently defective: Ion specifies that an
out-of-bounds SID must evoke an error and stop parsing. Proper modeling of such
failures is WIP.

To handle annotations, we'll need a recursive function expanding a sequence of
symbol tokens:

[{denotation}]
++++
include::{modeltex}[tag=E_RSymTok*]
++++


=== Non-Top Value Expansion

Now we can define how non-top raw values are expanded.
Expansion of a single **RValue** requires separate expansion of its annotations
and content, combining the results into a **Value**:

[{denotation}]
++++
include::{modeltex}[tag=E]
++++

We expand a sequence of **RValue**s by simple recursion:

[{denotation}]
++++
include::{modeltex}[tag=E*]
++++

To expand **RContent** we must perform a type-switch.
**SafeVal**s pass through easily by being re-wrapped as **Content**.
Anything else can contain symbol tokens to be expanded, and in each case we
downcast the content, call a type-specific function, then rewrap the result.

[{denotation}]
++++
include::{modeltex}[tag=E_RContent]
++++

Expanding **RSymbol** just requires distinguishing `symbol.null`:

[{denotation}]
++++
include::{modeltex}[tag=E_RSymbol]
++++

Expanding **RList** is similar, with recursion on its sequence of elements:

[{denotation}]
++++
include::{modeltex}[tag=E_RList]
++++

To handle **RStruct** with the same pattern, we'll add a helper to expand its
sequence of fields:

[{denotation}]
++++
include::{modeltex}[tag=E_RStruct]
++++

Field-sequence expansion takes a bit more work.  When the sequence is not empty,
we expand the field's name and value using the appropriately-typed variants of
stem:[{\cal E}].  We turn those into a field and prepend it onto the result of
(self-recursively) expanding the sequence's tail.

[{denotation}]
++++
include::{modeltex}[tag=E_RField*]
++++

At this point we have fully denoted the expansion of non-top-level raw values,
and can turn to the top level.


[id=eg_TE]
=== Top-Level Expansion

Expansion of top-level sequences requires us to use a new technique in our model,
since it involves changes to the environment.  For example, the expansion of an
IVM or LST must produce a new environment, but no application values.

The conventional way to represent order of evaluation and mutation of state in
denotational semantics is via _continuation-passing style_.
This style accounts for the fact that lambda calculus is purely functional and
has no concept of either evaluation order or mutation.
We've managed to avoid continuations so far because Ion only needs these
features at top level.

Diving right in, let's see how to expand a single top-level value.
We'll use overlines like stem:[\overline{\cal E}] and stem:[\overline{rv}]
to signal top-level functions and variables.

[{denotation}]
++++
include::{modeltex}[tag=TContinuation]
\newline\newline
include::{modeltex}[tag=TE]
++++

There's three branches here, covering IVMs, symbol-table directives, and
"`normal`" values:

* When we encounter an IVM, we must reset the environment using a helper
function that we'll implement later.
We pass that to the continuation along with an empty value sequence, since the
IVM is not part of the application data.
The current environment stem:[\rho] not passed to the continuation and is
therefore inaccessible to any remaining data on the stream.

* Top-level raw values that are not IVMs are expanded using stem:[\cal E] and the
current environment stem:[\rho].
The resulting *Value* _v_ is then checked to see if it's an LST directive, in
which case we use its content, downcast to *Struct*, to construct the new
environment.

* In the final case, our result _v_ is just a user value, so we pass it to the
continuation along with the unaltered environment.

In accordance with continuation-passing style, stem:[\overline{\cal E}] never
returns results "`directly`", it always invokes the continuation stem:[\kappa]
with the now-current environment and any application values it produces.
The continuation is responsible for assembling those results with anything
that happens afterward, and the **Value**s returned from the continuation denote
the expansion of _the entire stream_.

This may become more clear by considering the definition of top-level streams:

[{denotation}]
++++
include::{modeltex}[tag=TE*]
++++

Here we have our most complex denotation yet, so let's break it down.

* The **if** and **then** clauses simply detect and handle the empty-sequence base
case.
* When the sequence is non-empty, we expand (with stem:[\overline{\cal E}])
its head (stem:[\overline{\mbox{\it rv\/}^{\ast}}\!\downarrow_{0}]) using the
current environment stem:[\rho] and a locally-defined continuation, which will
be invoked with the _next_ environment stem:[\rho_1] and any expanded
application values stem:[\mbox{\it v\/}^{\ast}_{1}].
* That continuation is responsible for handling the rest of the stream, so it
expands (with self-recursion on stem:[\overline{{\cal E}^{\ast}}]) that tail
(stem:[\overline{\mbox{\it rv\/}^{\ast}}\dagger1]) using whatever environment we
got from the head (stem:[\rho_1]).
* Those results are passed to a second local continuation.
We now have stem:[\rho_2] holding the environment in effect at the end of the
sequence, and stem:[\mbox{\it v\/}^{\ast}_{2}] holding the expansion of the
tail of our overall sequence.
To produce the overall results, we call our original continuation stem:[\kappa]
with that final environment and the concatenation of the head and tail
expansions (stem:[\mbox{\it v\/}^{\ast}_{1}\S\mbox{\it v\/}^{\ast}_{2}]).

The last thing we need is a way to launch expansion, via the user-facing
__expand__ function that we originally set out to achieve:

[{denotation}]
++++
include::{modeltex}[tag=expand]
++++

This simply invokes stem:[\overline{{\cal E}^{\ast}}] with an initial
environment and continuation.
The initial environment is constructed from the user's catalog in Ion 1.0 mode,
with the appropriate symbol table provided a helper method.
The initial continuation, destined to receive the final expansion results,
discards the final environment and passes the user their data.

We've now concluded the denotation functions specifying the expansion of
symbol IDs and the handling of encoding directives in Ion 1.0 documents.
However, we've glossed over the mechanics of those directives by using some
helper functions we've yet to define.
The next sections will drill down into those details.


[#symtabs]
== Symbol Table Management

The handling of symbol tables brings us to some of the more lengthy functions
in this denotational model. The specified algorithms include a fair
amount of type-checking and default values to ensure that even nonsensical
directives have a well-defined and stable interpretation across implementations.
Put another way, the spec must leave nothing unspecified, so that whatever
gobbledygook appears inside an LST directive, all
implementations will behave the same way.


=== System Symbol Tables

Following an IVM, the current symbol table is set to the system symbols for the
given major and minor version of Ion.
This is straightforward to define.
First we define the content of the system symbol table for a given Ion version:

[{denotation}]
++++
include::{modeltex}[tag=SymToks_for_IVM]
++++

(Apologies for the failure of our pretty printer, but you get the idea.)

Then we define the environment that becomes current after the IVM is
encountered.  It retains the current environment's catalog,
but replaces the IVM and resets the symbol table to that of the new Ion version.

[{denotation}]
++++
include::{modeltex}[tag=Environment_after_IVM]
++++


=== Installing Local Symbol Tables

To start handling local symbol table directives, we must first recognize them by
checking the annotation and content type:

[{denotation}]
++++
include::{modeltex}[tag=is_LST]
++++

We can then turn the annotated struct into a sequence of symbol tokens that will
soon become the current symbol table:

[{denotation}]
++++
include::{modeltex}[tag=SymToks_for_LST]
++++

Here we encounter the first of many null checks. In particular, top-level
`$ion_symbol_table::null.symbol` is equivalent to `$ion_symbol_table::{}`.
When the directive is not null, we concatenate the imported symbols and the
locally-declared symbols.
The former sequence includes any symbols implicitly imported from the current
Ion version.

The resulting environment after such a directive is as follows:

[{denotation}]
++++
include::{modeltex}[tag=Environment_after_LST]
++++

Here we see that the directive has the effect of retaining the current catalog
and Ion version, replacing only the current symbols.
More importantly, we see that an LST directive is fully expanded using the
environment in effect when it begins.
The locally-declared symbols have no effect on the encoding of any part of the
enclosing struct.
Their scope only starts with the next top-level value.

TIP: At this point it may be worth reviewing the definition of
stem:[\overline{\cal E}] in xref:eg_TE[xrefstyle=short].


=== Compiling Local Symbol Tables

The functions above sidestep the more heavy-duty work of turning a symbol-table
directive into **SymTok**{asterisk} by delegating to helper functions
__imported_symbols__ and __declared_symbols__.
For lack of a better word, we'll refer to this process as "`compilation`" of the
directive.  What follows is effectively a recursive-descent process over the
directive's fully-expanded *Struct*.


==== Declared Symbols

Starting with the easy part, we compile the `symbols` field into
**SymTok**{asterisk}.

[{denotation}]
++++
include::{modeltex}[tag=declared_symbols]
++++

First, recall that _Struct_get1_ returns a sequence of zero or one values,
raising an error if the field is repeated in the struct.
When there's no `symbols` declared, we simply return an empty sequence.
We do the same thing when the field-value's content is not a *List*.
Given a list, we compile its elements as follows:

[{denotation}]
++++
include::{modeltex}[tag=compile_symbols_elts]
++++

This recursively compiles each list element into a *SymTok*.
For content that is a *String* and not null, we extract the Unicode and rewrap
it.  All other values produce `$0`.


==== Imported Symbols

We follow similar patterns for the `imports` field.
Remember that these results are expected to contain the appropriate system
symbols.

[{denotation}]
++++
include::{modeltex}[tag=imported_symbols]
++++

When `imports` are absent, we return the current system symbols.
If `imports` is the symbol `$ion_symbol_table`, we return the entire
current symbol table.  When the content is a non-null *List*, we compile its
elements and append them to the current system symbols; otherwise the field
has an unexpected value, and we act is if it were absent.

Compiling the `imports` elements is similar to _compile_symbols_elts_ but each
element produces a list of tokens, not just one:

[{denotation}]
++++
include::{modeltex}[tag=compile_imports_elts]
++++

As expected, we recurse through the elements of stem:[v^{\ast}], compiling
non-null **Struct**s and ignoring the rest.  To compile one such struct, we
first normalize its meaningful fields, ignoring the rest:

[{denotation}]
++++
include::{modeltex}[tag=compile_import_struct]
++++

The normalization of each field involves checking for absence, type, and nulls.
For `name` we return the text of non-null **String**s, normalizing everything
else to the empty string:

[{denotation}]
++++
include::{modeltex}[tag=normalize_name]
++++

For `version` we normalize to 1 when absent, malformed, or less than one:

[{denotation}]
++++
include::{modeltex}[tag=normalize_version]
++++

For `max_id` we normalize to -1 when absent or malformed.
Later, we'll handle all negative values uniformly as if the field were absent.

[{denotation}]
++++
include::{modeltex}[tag=normalize_max_id]
++++

Having extracted the field values from the struct, we can produce a sequence of
**SymTok**s retrieved from the catalog.

[{denotation}]
++++
include::{modeltex}[tag=compile_import]
++++

First, we ignore malformed/absent names, as well as the name `$ion`: you cannot
explicitly import a system symbol table.
_Catalog_lookup_ (coming soon!) searches the catalog for the best match to the
name and version; it returns a sequence of at-most-one *SharedSymtab*.

If no SST was found, we check the declared _max_id_; if it was (normalized to)
absent, we raise an error, otherwise we return `max_id` copies of `$0`.

If a SST was found in the catalog, we compare its version to the one requested.
When they are equal, we have an exact-match and if `max_id` is well-formed we
adjust the number of symtoks appropriately.
When they are not equal, `max_id` _must_ be well-formed, and we adjust the
length.

The functions to adjust the sequence length are straightforward.
_symbol_padding_ produces a sequence of _n_ copies of `$0`, and _adjust_length_
takes a **SymTok**{asterisk} and either truncates it or pads it with `$0`.

[{denotation}]
++++
include::{modeltex}[tag=symbol_padding]
\newline\newline
include::{modeltex}[tag=adjust_length]
++++


=== Shared Symbol Tables and Catalogs

We are down to our final denotations: the behavior of catalogs and the shared
symbol tables they contain.  We've already defined the relevant domains:

[{denotation}]
++++
include::{modeltex}[tag=SharedSymtab]
\newline
include::{modeltex}[tag=Catalog]
++++

A shared symbol table consists of a name, a version, and a sequence of
**SymTok**s, each of which is either *Unicode* text or *Sym0* (that is, `$0`).
Accessor functions help clarify:

[{denotation}]
++++
include::{modeltex}[tag=SST_name]
\newline
include::{modeltex}[tag=SST_version]
\newline
include::{modeltex}[tag=SST_symbols]
++++

Ion defines a standard serialization of SSTs, which we can easily parse:

[{denotation}]
++++
include::{modeltex}[tag=is_SST]
\newline\newline
include::{modeltex}[tag=compile_SST]
++++

CAUTION: The above needs error handling similar to local symbol tables.

A catalog is just a sequence of shared symtabs.
What's tricky is implementing the "`best match`" semantics required by the Ion
specification: if there's no exact match to the requested version, we must
return the largest version available.

[{denotation}]
++++
include::{modeltex}[tag=Catalog_lookup]
++++

_Catalog_lookup_ recursively walks the catalog to find the best match.
The signature of _seek_ is a bit subtle.
The first argument stem:[s^{\ast}] is the set of symtabs still-to-be-scanned,
followed by the requested name _n_ and version _v_.
The fourth argument stem:[b^{\ast}] is an at-most-one sequence holding the best
match (largest version) found so far with the requested name.
The result is an at-most-one sequence holding the best match.

If the current _sst_ has the requested name and version, we skip recursion and
return it directly. Otherwise, we check whether its version is larger than the
_best_ so far, in which case we replace _best_ for the recursive call.


[#issues]
== Known Issues

This denotational model is currently defective with respect to the published Ion
specification in the following ways.


=== Improper ordering of structs fields

Structs are unordered, but this model currently denotes them as sequences.
This means that the same field-values in different order will _not_ be
equivalent per lambda calculus.  Denoting this properly is possible (by
constructing the set of all permutations) but requires a fair amount of code.


=== Improper equivalence of unknown shared symbols

The model maps all unknown shared symbols to `$0` and therefore they are all
equivalent to the model.  This is incorrect per
https://amazon-ion.github.io/ion-docs/docs/symbols.html#data-model[the spec],
which says:

[quote]
____
For symbols defined from shared symbol table imports, [unknown] symbols are
equivalent only if all of the following hold:

* The name of the table that the symbols were imported from is the same string.
* The position in the table that the symbols were imported from is the same
spot.
____

https://amazon-ion.github.io/ion-docs/docs/symbols.html#symbol-zero[Further],

[quote]
____
It is important to note that `$0` is only semantically equivalent to itself and
to locally-declared SIDs with unknown text. It is not semantically equivalent to
SIDs with unknown text from shared symbol tables, so replacing such SIDs with
`$0` is a destructive operation to the semantics of the data.
____

To handle this, *SymTok* needs a subdomain to capture the SST and index.

=== Error handling is too informal

At present our model skirts around error handling by way of _raise_ but
conventional handling uses a bottom-type stem:[\bot] to denote failures and
strictness rules to forcibly propagate them.  We simply haven't implemented this
in the framework that underlies this model.

=== Out of bounds SIDs must raise an error

This is primarily a result of the above lack of framework support and our desire
to test the size of the current symbol table.

=== Shared symbol table compilation is weak

We don't type check the inputs, which "`crashes`" the math when given bad data.
This doesn't really affect the important parts of the model.

On a related note, catalog construction should reject duplicate keys, so we
don't imply anything about selection criteria.

=== Repeated text in SSTs should become undefined

[quote]
____
When mapping from string to symbol ID, there may be multiple associated IDs (the
same string could appear twice as children of the symbols field).
Implementations MUST select the lowest known ID, and all other associated IDs
MUST be handled as if undefined.
____

It's a bit unclear why this clause exists, but the model doesn't specify it.


[appendix]
== The Full Denotation

=== Domains

[{denotation}]
++++
include::{modeltex}[tag=domains]
++++

=== Functions

[{denotation}]
++++
include::{modeltex}[tag=functions]
++++
