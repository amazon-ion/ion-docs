[[sec:binary_encoding]]
== Ion 1.1 Binary Encoding

[[encoding_primitives]]
=== Encoding Primitives

[[flexuint]]
==== `FlexUInt`

A variable-length unsigned integer.

The bytes of a ``FlexUInt``s are written in
link:https://en.wikipedia.org/wiki/Endianness:[little-endian byte order]. This means that the first bytes will contain
the ``FlexUInt``'s least significant bits.

The least significant bits in the `FlexUInt` indicate the number of bytes that were used to encode the integer.
If a `FlexUInt` is `_N_` bytes long, its `_N-1_` least significant bits will be `0`; a terminal `1` bit will be
in the next most significant position.
All bits that are more significant than the terminal `1` represent the magnitude of the `FlexUInt`.

.Figure {counter:figure}: `_FlexUInt_` encoding of `_14_`
[%unbreakable]
----
              ┌──── Lowest bit is 1 (end), indicating
              │     this is the only byte.
0 0 0 1 1 1 0 1
└─────┬─────┘
unsigned int 14
----

.Figure {counter:figure}: `_FlexUInt_` encoding of `_729_`
[%unbreakable]
----
             ┌──── There's 1 zero in the least significant bits, so this
             │     integer is two bytes wide.
            ┌┴┐
0 1 1 0 0 1 1 0  0 0 0 0 1 0 1 1
└────┬────┘      └──────┬──────┘
lowest 6 bits    highest 8 bits
of the unsigned  of the unsigned
integer          integer
----

.Figure {counter:figure}: `_FlexUInt_` encoding of `_21,043_`
[%unbreakable]
----
            ┌───── There are 2 zeros in the least significant bits, so this
            │      integer is three bytes wide.
          ┌─┴─┐
1 0 0 1 1 1 0 0  1 0 0 1 0 0 0 1  0 0 0 0 0 0 1 0
└───┬───┘        └──────┬──────┘  └──────┬──────┘
lowest 6 bits    next 8 bits of   highest 8 bits
of the unsigned  the unsigned     of the unsigned
integer          integer          integer
----

[[flexint]]
==== `FlexInt`

A variable-length signed integer.

From an encoding perspective, ``FlexInt``s are structurally similar to a `FlexUInt` (<<flexuint, described above>>). Both
encode their bytes using little-endian byte order, and both use the count of least-significant zero bits to indicate
how many bytes were used to encode the integer. They differ in the _interpretation_ of their bits; while a
``FlexUInt``'s bits are unsigned, a ``FlexInt``'s bits are encoded using
link:https://en.wikipedia.org/wiki/Two%27s_complement[two's complement notation].

TIP: An implementation could choose to read a `FlexInt` by instead reading a `FlexUInt` and then reinterpreting its bits
as two's complement.

.Figure {counter:figure}: `_FlexInt_` encoding of `_14_`
[%unbreakable]
----
              ┌──── Lowest bit is 1 (end), indicating
              │     this is the only byte.
0 0 0 1 1 1 0 1
└─────┬─────┘
 2's comp. 14
----

.Figure {counter:figure}: `_FlexInt_` encoding of `_-14_`
[%unbreakable]
----
              ┌──── Lowest bit is 1 (end), indicating
              │     this is the only byte.
1 1 1 0 0 1 0 1
└─────┬─────┘
 2's comp. -14
----

.Figure {counter:figure}: `_FlexInt_` encoding of `_729_`
[%unbreakable]
----
             ┌──── There's 1 zero in the least significant bits, so this
             │     integer is two bytes wide.
            ┌┴┐
0 1 1 0 0 1 1 0  0 0 0 0 1 0 1 1
└────┬────┘      └──────┬──────┘
lowest 6 bits    highest 8 bits
of the 2's       of the 2's
comp. integer    comp. integer
----

.Figure {counter:figure}: `_FlexInt_` encoding of `_-729_`
[%unbreakable]
----
             ┌──── There's 1 zero in the least significant bits, so this
             │     integer is two bytes wide.
            ┌┴┐
1 0 0 1 1 1 1 0  1 1 1 1 0 1 0 0
└────┬────┘      └──────┬──────┘
lowest 6 bits    highest 8 bits
of the 2's       of the 2's
comp. integer    comp. integer
----

[[fixeduint]]
==== `FixedUInt`

A fixed-width, little-endian, unsigned integer whose length is inferred from the context in which it appears.

.Figure {counter:figure}: `_FixedUInt_` encoding of `_3,954,261_`
[%unbreakable]
----

0 1 0 1 0 1 0 1  0 1 0 1 0 1 1 0  0 0 1 1 1 1 0 0
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
lowest 8 bits    next 8 bits of   highest 8 bits
of the unsigned  the unsigned     of the unsigned
integer          integer          integer
----

[[fixedint]]
==== `FixedInt`

A fixed-width, little-endian, signed integer whose length is known from the context in which it appears. Its bytes
are interpreted as two's complement.

.Figure {counter:figure}: `_FixedInt_` encoding of `_-3,954,261_`
[%unbreakable]
----

1 0 1 0 1 0 1 1  1 0 1 0 1 0 0 1  1 1 0 0 0 0 1 1
└──────┬──────┘  └──────┬──────┘  └──────┬──────┘
lowest 8 bits    next 8 bits of   highest 8 bits
of the 2's       the 2's comp.    of the 2's comp.
comp. integer    integer          integer
----

[[flexsym]]
==== `FlexSym`

A variable-length symbol token whose UTF-8 bytes can be inline, found in the symbol table, or derived from a macro
expansion.

A `FlexSym` begins with a <<flexint,`FlexInt`>>; once this integer has been read, we can evaluate it to determine how to proceed. If the FlexInt is:

* *greater than zero*, it represents a symbol ID. The symbol’s associated text can be found in the local symbol table.
No more bytes follow.
* *less than zero*, its absolute value represents a number of UTF-8 bytes that follow the `FlexInt`. These bytes
represent the symbol’s text.
* *exactly zero*, another byte follows that is an <<opcodes, opcode>>. The `FlexSym` parser is not responsible for
evaluating this opcode, only returning it—the caller will decide whether the opcode is legal in the current context.
Example usages of the opcode include:
** Representing SID `$0` as `0x60`.
** Representing system symbols (`0x61`-`0xDF`), where the system symbol ID is biased by `0x60`.
*** Note that the empty symbol (i.e. the symbol `''`) is now a system symbol and can be referenced this way.
** When used to encode a struct field name, the opcode can invoke a macro that will evaluate to a struct whose key/value
pairs are spliced into the parent struct (TODO: Link)
** In a <<delimited_structs, delimited struct>>, terminating the sequence of `(field name, value)` pairs with `0xF0`.

.Figure {counter:figure}: `_FlexSym_` encoding of symbol ID `_$10_`
[%unbreakable]
----
              ┌─── The leading FlexInt ends in a `1`,
              │    no more FlexInt bytes follow.
              │
0 0 0 1 0 1 0 1
└─────┬─────┘
  2's comp.
  positive 10
----

.Figure {counter:figure}: `_FlexSym_` encoding of symbol text `_'hello'_`
[%unbreakable]
----
              ┌─── The leading FlexInt ends in a `1`,
              │    no more FlexInt bytes follow.
              │      h         e        l        l        o
1 1 1 1 0 1 1 1  01101000  01100101 01101100 01101100 01101111
└─────┬─────┘    └─────────────────────┬─────────────────────┘
  2's comp.               5-byte UTF-8 encoded "hello"
  negative 5
----

.Figure {counter:figure}: `_FlexSym_` encoding of `''` (empty text) using an opcode
[%unbreakable]
----
              ┌─── The leading FlexInt ends in a `1`,
              │    no more FlexInt bytes follow.
              │

0 0 0 0 0 0 0 1   01100000
└─────┬─────┘     └───┬──┘
  2's comp.      SSID 0x60:
  zero           empty symbol
----

.Figure {counter:figure}: `_FlexSym_` encoding of the system symbol `'name'`
[%unbreakable]
----
              ┌─── The leading FlexInt ends in a `1`,
              │    no more FlexInt bytes follow.
              │

0 0 0 0 0 0 0 1   01100100
└─────┬─────┘     └───┬──┘
  2's comp.         0x64:
  zero              Indicates SSID 4
----

NOTE: From this point on in the document, example encodings are given in hexadecimal notation.

[[opcodes]]
=== Opcodes

An _opcode_ is a 1-byte <<fixeduint, `FixedUInt`>> that tells the reader what the next expression represents
and how the bytes that follow should be interpreted.

The meanings of each opcode are organized loosely by their high and low nibbles.

[cols="^.^1a,^.^1a,3a"]
|===
|High nibble | Low nibble | Meaning

|`0x0_` to `0x3_`
|`0`-`F`
|E-expression with the address in the opcode

|`0x4_`
|`0`-`F`
|E-expression with the address as a trailing 1-byte `FixedUInt`.

|`0x5_`
|`0`-`F`
|E-expression with the address as a trailing 2-byte `FixedUInt`.

.4+|`0x6_`

|`0`-`8`
|Integers up to 8 bytes wide

|`9`
<|_Reserved_

|`A`-`D`
<|Floats

|`E`-`F`
<|Booleans

|`0x7_`
|`0`-`F`
|Decimals

.2+|`0x8_`

|`0`-`C`
|Timestamps

|`D`-`F`
<|_Reserved_

|`0x9_`
|`0`-`F`
|Strings

|`0xA_`
|`0`-`F`
|Symbols with inline text

|`0xB_`
|`0`-`F`
|Lists

|`0xC_`
|`0`-`F`
|S-expressions

.3+|`0xD_`
|`0`
|Empty struct

|`1`
<|_Reserved_

|`2`-`F`
<|Structs with symbol address field names

.9+|`0xE_`
|`0`
|Ion version marker

|`1`-`3`
<|Symbols with symbol address

|`4`-`6`
<|Annotations with symbol address

|`7`-`9`
<|Annotations with `FlexSym` text

|`A`
<|`null.null`

|`B`
<|Typed nulls

|`C`-`D`
<|NOP

|`E`
<|E-expression with a variable-width address

|`F`
<|System symbol or macro invocation

.16+|`0xF_`
|`0`
|Delimited container end

|`1`
<|Delimited list start

|`2`
<|Delimited S-expression start

|`3`
<|Delimited struct with `FlexSym` field names start

|`4`
<|_Reserved_

|`5`
<|Variable length prefixed macro invocation

|`6`
<|Variable length integer

|`7`
<|Variable length decimal

|`8`
<|Variable length, long-form timestamp

|`9`
<|Variable length string

|`A`
<|Variable length symbol encoded as `FlexSym`

|`B`
<|Variable length list

|`C`
<|Variable length S-expression

|`D`
<|Variable length struct with symbol address field names

|`E`
<|Variable length blob

|`F`
<|Variable length clob

|===


[[bin:eexp]]
=== Encoding Expressions

The encoding of E-expressions is designed to balance density and generality.
For example, they enable encodings with minimal tag bits, even none at all given
a thoughtful signature. This increases density, but limits generality at the point
of macro invocation.

The <<sec:eexprs,text>> and binary forms of E-expressions enforce the same
syntactic constraints on the type and range of data allowed as arguments.
Any syntactically well-formed E-expression can be transcoded between text and binary,
without expansion and without changing semantics, and independent of whether it can
be expanded successfully.


[[e_expression_with_the_address_in_the_opcode]]
==== E-expression With the Address in the Opcode

// TODO: link to macros chapter

If the value of the opcode is less than `64` (`0x40`), it represents an E-expression invoking the macro at the
corresponding __address__—an offset within the local macro table.

.Figure {counter:figure}: Invocation of macro address `_7_`
[%unbreakable]
----
┌──── Opcode in 00-3F range indicates an e-expression
│     where the opcode value is the macro address
│
07
└── FixedUInt 7
----

.Figure {counter:figure}: Invocation of macro address `_31_`
[%unbreakable]
----
┌──── Opcode in 00-3F range indicates an e-expression
│     where the opcode value is the macro address
│
1F
└── FixedUInt 31
----

Note that the opcode alone tells us which macro is being invoked, but it does not supply enough information for the
reader to parse any arguments that may follow. The parsing of arguments is described in detail in the section _Macro
calling conventions_. (TODO: Link)

[[e_expression_with_the_address_as_a_trailing_fixeduint]]
==== E-expression With the Address as a Trailing `FixedUInt`

While E-expressions invoking macro addresses in the range `[0, 63]` can be encoded in a single byte using
<<e_expression_with_the_address_in_the_opcode, E-expressions with the address in the opcode>>,
many applications will benefit from defining more than 64 macros.

The `0x4_` and `0x5_` opcodes can be used to represent over 1 million macro addresses.
If the high nibble of the opcode is `0x4_`, then a biased address follows as a 1-byte FixedUInt.
If the high nibble of the opcode is `0x5_`, then a biased address follows as a 2-byte FixedUInt.
In both cases, the address is biased by the total number of addresses with lower opcodes.
For `0x4_`, the bias is `256 * low_nibble + 64` (or `(low_nibble shift-left 8) + 64`).
For `0x5_`, the bias is `65536 * low_nibble + 4160`.

.Figure {counter:figure}: Invocation of macro address `_841_`
[%unbreakable]
----
┌──── Opcode in range 40-4F indicates a macro address with 1-byte FixedUInt address
│┌─── Low nibble 3 indicates bias of 832
││
43 09
   │
   └─── FixedUInt 9

Biased Address : 9
Bias : 832
Address : 841
----

.Figure {counter:figure}: Invocation of macro address `_142,918_`
[%unbreakable]
----
┌──── Opcode in range 50-5F indicates a macro address with 2-byte FixedUInt address
│┌─── Low nibble 2 indicates bias of 135232
││
52 06 1E
   └─┬─┘
     └─── FixedUInt 7686

Biased Address : 7686
Bias : 135232
Address : 142918
----

// TODO: Can we format this table in a better way?

.Macro address bias for `0x4_` and `0x5_` opcodes
[cols="^.^1a,^.^1a,^.^1a]
|===
|Low Nibble| `**0x4_**` Bias| `**0x5_**` Bias

| `0` | `64` | `4160`
| `1` | `320` | `69696`
| `2` | `576` | `135232`
| `3` | `832` | `200768`
| `4` | `1088` | `266304`
| `5` | `1344` | `331840`
| `6` | `1600` | `397376`
| `7` | `1856` | `462912`
| `8` | `2112` | `528448`
| `9` | `2368` | `593984`
| `A` | `2624` | `659520`
| `B` | `2880` | `725056`
| `C` | `3136` | `790592`
| `D` | `3392` | `856128`
| `E` | `3648` | `921664`
| `F` | `3904` | `987200`
|===

[[e_expression_with_the_address_as_a_trailing_flexuint]]
==== E-expression With the Address as a Trailing `FlexUInt`

Because the address is encoded using a `FlexUInt`, there is no (theoretical) limit to the number of addresses that can
be invoked. However, larger addresses require more bytes to encode.

When using the `0xEE` opcode, the address is unbiased; the `0xEE` opcode can be used for _any_ macro address.


.Figure {counter:figure}: Invocation of macro address `_0_`
[%unbreakable]
----
┌──── Opcode EE indicates a macro address as trailing FlexUInt
│  ┌─── FlexUInt 0
│  │
EE 01
----

.Figure {counter:figure}: Invocation of macro address `_2,097,151_`
[%unbreakable]
----
┌──── Opcode EE indicates a macro address as trailing FlexUInt
│  ┌─── FlexUInt 2097151
│  │
EE FC FF FF
----

[[e_expression_invoking_a_macro_from_the_system_module]]
==== E-expression invoking a macro from the system module

E-expression that invoke a system macro can be encoded using the `0xEF` opcode followed by a _positive_ 1-byte `FixedInt`.
(Negative values are used for <<system_symbols, system symbols>>.)

.Figure {counter:figure}: Encoding of the system macro `_values_`
[%unbreakable]
----
┌──── Opcode 0xEF indicates a system symbol or macro invocation
│  ┌─── FixedInt 0 indicates macro 0 from the system macro table
│  │
EF 00
----

In addition, system macros MAY be invoked using any of the `0x00`-`0x5F` or `0xEE` opcodes, provided that the macro being invoked has been given an address in user macro address space.

// TODO: Add link to "system-module" page.


[[booleans]]
=== Booleans

`0x6E` represents boolean `true`, while `0x6F` represents boolean `false`.

`0xEB 0x00` represents `null.bool`.

.Figure {counter:figure}: Encoding of boolean `_true_`
[%unbreakable]
----
6E
----

.Figure {counter:figure}: Encoding of boolean `_false_`
[%unbreakable]
----
6F
----

.Figure {counter:figure}: Encoding of `_null.bool_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: boolean
│  │
EB 00
----

[[numbers]]
=== Numbers

[[integers]]
==== Integers

Opcodes in the range `0x60` to `0x68` represent an integer. The opcode is followed by a <<fixedint, `FixedInt`>> that
represents the integer value. The low nibble of the opcode (`0x_0` to `0x_8`) indicates the size of the `FixedInt`.
Opcode `0x60` represents integer `0`; no more bytes follow.

Integers that require more than 8 bytes are encoded using the variable-length integer opcode `0xF6`,
followed by a
<<flexuint, FlexUInt>> indicating how many bytes of representation data follow.

`0xEB 0x01` represents `null.int`.

.Figure {counter:figure}: Encoding of integer `_0_`
[%unbreakable]
----
┌──── Opcode in 60-68 range indicates integer
│┌─── Low nibble 0 indicates
││    no more bytes follow.
60
----

.Figure {counter:figure}: Encoding of integer `_17_`
[%unbreakable]
----
┌──── Opcode in 60-68 range indicates integer
│┌─── Low nibble 1 indicates
││    a single byte follows.
61 11
    └── FixedInt 17
----

.Figure {counter:figure}: Encoding of integer `_-944_`
[%unbreakable]
----
┌──── Opcode in 60-68 range indicates integer
│┌─── Low nibble 2 indicates
││    that two bytes follow.
62 50 FC
   └─┬─┘
FixedInt -944
----

.Figure {counter:figure}: Encoding of integer `_-944_`
[%unbreakable]
----
┌──── Opcode F6 indicates a variable-length integer, FlexUInt length follows
│   ┌─── FlexUInt 2; a 2-byte FixedInt follows
│   │
F6 05 50 FC
      └─┬─┘
   FixedInt -944
----

.Figure {counter:figure}: Encoding of `_null.int_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: integer
│  │
EB 01
----

[[floats]]
==== Floats

Float values are encoded using the IEEE-754 specification in little-endian byte order. Floats can be serialized in
four sizes:

* 0 bits (0 bytes), representing the value 0e0 and indicated by opcode `0x6A`
* 16 bits (2 bytes in little-endian order, link:https://en.wikipedia.org/wiki/Half-precision_floating-point_format[half precision]),
indicated by opcode `0x6B`
* 32 bits (4 bytes in little-endian order, link:https://en.wikipedia.org/wiki/Single-precision_floating-point_format[single precision]),
indicated by opcode `0x6C`
* 64 bits (8 bytes in little-endian order, link:https://en.wikipedia.org/wiki/Double-precision_floating-point_format[double precision]),
indicated by opcode `0x6D`

Note that in the Ion data model, float values are always 64 bits. However, if a value can be losslessly serialized
in fewer than 64 bits, Ion implementations may choose to do so.

`0xEB 0x02` represents `null.float`.

.Figure {counter:figure}: Encoding of float `_0e0_`
[%unbreakable]
----
┌──── Opcode in range 6A-6D indicates a float
│┌─── Low nibble A indicates
││    a 0-length float; 0e0
6A
----

.Figure {counter:figure}: Encoding of float `_3.14e0_`
[%unbreakable]
----
┌──── Opcode in range 6A-6D indicates a float
│┌─── Low nibble B indicates a 2-byte float
││
6B 47 42
   └─┬─┘
half-precision 3.14
----

.Figure {counter:figure}: Encoding of float `_3.1415927e0_`
[%unbreakable]
----
┌──── Opcode in range 6A-6D indicates a float
│┌─── Low nibble C indicates a 4-byte,
││    single-precision value.
6C DB 0F 49 40
   └────┬────┘
single-precision 3.1415927
----

.Figure {counter:figure}: Encoding of float `_3.141592653589793e0_`
[%unbreakable]
----
┌──── Opcode in range 6A-6D indicates a float
│┌─── Low nibble D indicates an 8-byte,
││    double-precision value.
6D 18 2D 44 54 FB 21 09 40
   └──────────┬──────────┘
double-precision 3.141592653589793
----

.Figure {counter:figure}: Encoding of `_null.float_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: float
│  │
EB 02
----

[[decimals]]
==== Decimals

If an opcode has a high nibble of `0x7_`, it represents a decimal. Low nibble values indicate
the number of trailing bytes used to encode the decimal.

The body of the decimal is encoded as a <<flexint, `FlexInt`>> representing its exponent, followed by a `FixedInt`
representing its coefficient. The width of the coefficient is the total length of the decimal encoding minus the length
of the exponent. It is possible for the coefficient to have a width of zero, indicating a coefficient of `0`. When
the coefficient is present but has a value of `0`, the coefficient is `-0`.

Decimal values that require more than 15 bytes can be encoded using the variable-length decimal opcode: `0xF7`.

`0xEB 0x03` represents `null.decimal`.

.Figure {counter:figure}: Encoding of decimal `_0d0_`
[%unbreakable]
----
┌──── Opcode in range 70-7F indicates a decimal
│┌─── Low nibble 0 indicates a zero-byte
││    decimal; 0d0
70
----

.Figure {counter:figure}: Encoding of decimal `_7d0_`
[%unbreakable]
----
┌──── Opcode in range 70-7F indicates a decimal
│┌─── Low nibble 2 indicates a 2-byte decimal
││
72 01 07
   |  └─── Coefficient: 1-byte FixedInt 7
   └─── Exponent: FlexInt 0
----

.Figure {counter:figure}: Encoding of decimal `_1.27_`
[%unbreakable]
----
┌──── Opcode in range 70-7F indicates a decimal
│┌─── Low nibble 2 indicates a 2-byte decimal
││
72 FD 7F
   |  └─── Coefficient: FixedInt 127
   └─── Exponent: 1-byte FlexInt -2
----

.Figure {counter:figure}: Variable-length encoding of decimal `_1.27_`
[%unbreakable]
----
┌──── Opcode F7 indicates a variable-length decimal
│
F7 05 FD 7F
   |  |  └─── Coefficient: FixedInt 127
   |  └───── Exponent: 1-byte FlexInt -2
   └─────── Decimal length: FlexUInt 2
----

.Figure {counter:figure}: Encoding of `_0d3_`, which has a coefficient of zero
[%unbreakable]
----
┌──── Opcode in range 70-7F indicates a decimal
│┌─── Low nibble 1 indicates a 1-byte decimal
││
71 07
   └────── Exponent: FlexInt 3; no more bytes follow, so the coefficient is implicitly 0
----

.Figure {counter:figure}: Encoding of `_-0d3_`, which has a coefficient of negative zero
[%unbreakable]
----
┌──── Opcode in range 70-7F indicates a decimal
│┌─── Low nibble 2 indicates a 2-byte decimal
││
72 07 00
   |  └─── Coefficient: 1-byte FixedInt 0, indicating a coefficient of -0
   └────── Exponent: FlexInt 3
----

.Figure {counter:figure}: Encoding of `_null.decimal_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: decimal
│  │
EB 03
----

[[timestamps]]
=== Timestamps

NOTE: In Ion 1.0, text timestamp fields were encoded using the local time while binary timestamp fields were encoded
using UTC time. This required applications to perform conversion logic when transcribing from one format to the other.
*In Ion 1.1, all binary timestamp fields are encoded in local time.*

Timestamps have two encodings:

Short-form timestamps:: A compact representation optimized for the most commonly used precisions and date ranges.

Long-form timestamps:: A less compact representation capable of representing any timestamp in the Ion data model.

`0xEB x04` represents `null.timestamp`.

.Figure {counter:figure}: Encoding of `_null.timestamp_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: timestamp
│  │
EB 04
----

[[short_form_timestamp]]
==== Short-form Timestamp

If an opcode has a high nibble of `0x8_`, it represents a short-form timestamp. This encoding focuses on making the
most common timestamp precisions and ranges the most compact; less common precisions can still be expressed via
the variable-length <<long_form_timestamp, long form timestamp>> encoding.

Timestamps may be encoded using the short form if they meet all of the following conditions:

The year is between 1970 and 2097.:: The year subfield is encoded as the number of years since 1970. 7 bits are
dedicated to representing the biased year, allowing timestamps through the year 2097 to be encoded in this form.
The local offset is either UTC, unknown, or falls between `-14:00` to `+14:00` and is divisible by 15 minutes.:: 7
bits are dedicated to representing the local offset as the number of quarter hours from -56 (that is: offset `-14:00`).
The value `0b1111111` indicates an unknown offset. At the time of this writing (2023-05T),
link:https://en.wikipedia.org/wiki/List_of_UTC_offsets[all real-world offsets fall between `-12:00` and `+14:00`
and are multiples of 15 minutes].
The fractional seconds are a common precision.::
The timestamp's fractional second precision (if present) is either 3 digits (milliseconds), 6 digits (microseconds),
or 9 digits (nanoseconds).

===== Opcodes by precision and offset

Each opcode with a high nibble of `0x8_` indicates a different precision and offset encoding pair.

[cols="^1a,^1a,^1a,.^4a"]
|===
|Opcode | Precision | Serialized size in bytes{asterisk} | Offset encoding

|`0x80`
|Year
|1
.3+|Implicitly _Unknown offset_

|`0x81`
|Month
|2

|`0x82`
|Day
|2

|`0x83`
|Hour and minutes
|4
.5+|1 bit to indicate _UTC_ or _Unknown Offset_

|`0x84`
|Seconds
|5

|`0x85`
|Milliseconds
|6

|`0x86`
|Microseconds
|7

|`0x87`
|Nanoseconds
|8

|`0x88`
|Hour and minutes
|5
.5+|7 bits to represent a known offset. +
 +
This encoding can also represent _UTC_ and _Unknown Offset_,
though it is less compact than opcodes `0x83`-`0x87` above.

|`0x89`
|Seconds
|5

|`0x8A`
|Milliseconds
|7

|`0x8B`
|Microseconds
|8

|`0x8C`
|Nanoseconds
|9

|`0x8D`
3.3+^.^|_Reserved_
|`0x8E`
|`0x8F`
|===
_{asterisk} Serialized size in bytes does not include the opcode._

The body of a short-form timestamp is encoded as a `FixedUInt` of the size specified by the opcode.  This integer is
then partitioned into bit-fields representing the timestamp's subfields.  Note that endianness does not apply here because the
bit-fields are defined over the body interpreted as an _integer_.

The following letters to are used to denote bits in each subfield in diagrams that follow. Subfields occur in the same
order in all encoding variants, and consume the same number of bits, with the exception of the fractional bits, which
consume only enough bits to represent the fractional precision supported by the opcode being used.

The `Month` and `Day` subfields are one-based; `0` is not a valid month or day.

[cols="^.^1a, ^.^1a, .^4a"]
|===
|Letter code | Number of bits | Subfield

| `Y`
| 7
| Year

| `M`
| 4
| Month

| `D`
| 5
| Day

| `H`
| 5
| Hour

| `m`
| 6
| Minute

| `o`
| 7
| Offset

| `U`
| 1
| Unknown (`0`) or UTC (`1`) offset

| `s`
|6
| Second

| `f`
| 10 (ms) +
20 (μs) +
30 (ns) +
| Fractional second

| `.`
| n/a
| Unused
|===

We will denote the timestamp encoding as follows with each byte ordered vertically from top to bottom.  The
respective bits are denoted using the letter codes defined in the table above.

[%unbreakable]
----
          7       0 <--- bit position
          |       |
         +=========+
byte 0   |  0xNN   | <-- hex notation for constants like opcodes
         +=========+ <-- boundary between encoding primitives (e.g., opcode/`FlexUInt`)
     1   |nnnn:nnnn| <-- bits denoted with a `:` as a delimeter to aid in reading
         +---------+ <-- octet boundary within an encoding primitive
         ...
         +---------+
     N   |nnnn:nnnn|
         +=========+
----

The bytes are read from top to bottom (least significant to most significant), while the bits within each byte should be
read from right to left (also least significant to most significant.)

NOTE: While this encoding may complicate human reading, it guarantees that the timestamp's subfields (`year`, `month`,
etc.) occupy the same bit contiguous indexes regardless of how many bytes there are overall. (The last subfield,
`fractional_seconds`, always begins at the same bit index when present, but can vary in length according to the
precision.) This arrangement allows processors to read the Little-Endian bytes into an integer and then mask the
appropriate bit ranges to access the subfields.

.Figure {counter:figure}: Encoding of a timestamp with year precision
[%unbreakable]
----
         +=========+
byte 0   |  0x80   |
         +=========+
     1   |.YYY:YYYY|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with month precision
[%unbreakable]
----
         +=========+
byte 0   |  0x81   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |....:.MMM|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with day precision
[%unbreakable]
----
         +=========+
byte 0   |  0x82   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with hour-and-minutes precision at UTC or unknown offset
[%unbreakable]
----
         +=========+
byte 0   |  0x83   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |....:Ummm|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with seconds precision at UTC or unknown offset
[%unbreakable]
----
         +=========+
byte 0   |  0x84   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |ssss:Ummm|
         +---------+
     5   |....:..ss|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with milliseconds precision at UTC or unknown offset
[%unbreakable]
----
         +=========+
byte 0   |  0x85   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |ssss:Ummm|
         +---------+
     5   |ffff:ffss|
         +---------+
     6   |....:ffff|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with microseconds precision at UTC or unknown offset
[%unbreakable]
----
         +=========+
byte 0   |  0x86   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |ssss:Ummm|
         +---------+
     5   |ffff:ffss|
         +---------+
     6   |ffff:ffff|
         +---------+
     7   |..ff:ffff|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with nanoseconds precision at UTC or unknown offset
[%unbreakable]
----
         +=========+
byte 0   |  0x87   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |ssss:Ummm|
         +---------+
     5   |ffff:ffss|
         +---------+
     6   |ffff:ffff|
         +---------+
     7   |ffff:ffff|
         +---------+
     8   |ffff:ffff|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with hour-and-minutes precision at known offset
[%unbreakable]
----
         +=========+
byte 0   |  0x88   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |oooo:ommm|
         +---------+
     5   |....:..oo|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with seconds precision at known offset
[%unbreakable]
----
         +=========+
byte 0   |  0x89   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |oooo:ommm|
         +---------+
     5   |ssss:ssoo|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with milliseconds precision at known offset
[%unbreakable]
----
         +=========+
byte 0   |  0x8A   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |oooo:ommm|
         +---------+
     5   |ssss:ssoo|
         +---------+
     6   |ffff:ffff|
         +---------+
     7   |....:..ff|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with microseconds precision at known offset
[%unbreakable]
----
         +=========+
byte 0   |  0x8B   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |oooo:ommm|
         +---------+
     5   |ssss:ssoo|
         +---------+
     6   |ffff:ffff|
         +---------+
     7   |ffff:ffff|
         +---------+
     8   |....:ffff|
         +=========+
----

.Figure {counter:figure}: Encoding of a timestamp with nanoseconds precision at known offset
[%unbreakable]
----
         +=========+
byte 0   |  0x8C   |
         +=========+
     1   |MYYY:YYYY|
         +---------+
     2   |DDDD:DMMM|
         +---------+
     3   |mmmH:HHHH|
         +---------+
     4   |oooo:ommm|
         +---------+
     5   |ssss:ssoo|
         +---------+
     6   |ffff:ffff|
         +---------+
     7   |ffff:ffff|
         +---------+
     8   |ffff:ffff|
         +---------+
     9   |..ff:ffff|
         +=========+
----

.Examples of short-form timestamps
[%unbreakable]
[cols="1a,.^1a"]
|===
| Text | Binary

| 2023T
| `80 35`

| 2023-10-15T
| `82 35 7D`

| 2023-10-15T11:22:33Z
| `84 35 7D CB 1A 02`

| 2023-10-15T11:22:33-00:00
| `84 35 7D CB 12 02`

| 2023-10-15T11:22:33+01:15
| `89 35 7D CB 2A 84`

| 2023-10-15T11:22:33.444555666+01:15
| `8C 35 7D CB 2A 84 92 61 7F 1A`
|===

WARNING: Opcodes `0x8D`, `0x8E`, and `0x8F` are illegal; they are reserved for future use.

[[long_form_timestamp]]
==== Long-form Timestamp

Unlike the <<short_form_timestamp, Short-form timestamp encoding>>, which is limited to encoding
timestamps in the most commonly referenced timestamp ranges and precisions for which it optimizes,
the long-form timestamp encoding is capable of representing any valid timestamp.

The long form begins with opcode `0xF8`. A <<flexuint, `FlexUInt`>> follows indicating the number
of bytes that were needed to represent the timestamp. The encoding consumes the minimum number
of bytes required to represent the timestamp. The declared length can be mapped to the timestamp’s
precision as follows:

[cols="^1, 6"]
|===
|Length | Corresponding precision

| 0
| _Illegal_

| 1
| _Illegal_

| 2
| Year

| 3
| Month or Day (see below)

| 4
| _Illegal; the hour cannot be specified without also specifying minutes_

| 5
| _Illegal_

| 6
| Minutes

| 7
| Seconds

| 8 or more
| Fractional seconds
|===

Unlike the short-form encoding, the long-form encoding reserves:

* *14 bits for the year (`Y`)*, which is not biased.
* *12 bits for the offset*, which counts the number of minutes (not quarter-hours) from -1440
(that is: `-24:00`). An offset value of `0b111111111111` indicates an unknown offset.

Similar to short-form timestamps, with the exception of representing the fractional seconds, the components of the
timestamp are encoded as bit-fields on a `FixedUInt` that corresponds to the length that followed the opcode.

If the timestamp's overall length is greater than or equal to `8`, the `FixedUInt` part of the timestamp is `7` bytes
and the remaining bytes are used to encode fractional seconds. The fractional seconds are encoded as a
`(scale, coefficient)` pair, which is _similar_ to a <<decimals, decimal>>. The primary difference is that the *scale*
represents a negative *exponent* because it is illegal for the fractional seconds value to be greater than or equal to
`1.0` or less than `0.0`. The scale is encoded as a `FlexUInt` (instead of `FlexInt`) to discourage the
encoding of decimal numbers greater than `1.0`. The coefficient is encoded as a `FixedUInt` (instead of `FixedInt`) to
prevent the encoding of fractional seconds less than `0.0`. Note that validation is still required; namely:

* A scale value of `0` is illegal, as that would result in a fractional seconds greater than `1.0` (a whole second).
* If `coefficient * 10^-scale > 1.0`, that `(coefficient, scale)` pair is illegal.

If the timestamp's length is `3`, the precision is determined by inspecting the day (`DDDDD`) bits. Like the short-form,
the `Month` and `Day` subfields are one-based (`0` is not a valid month or day). If the day subfield is zero, that
indicates month precision. If the day subfield is any non-zero number, that indicates day precision.

.Figure {counter:figure}: Encoding of the _body_ of a long-form timestamp
[%unbreakable]
----
         +=========+
byte 0   |YYYY:YYYY|
         +=========+
     1   |MMYY:YYYY|
         +---------+
     2   |HDDD:DDMM|
         +---------+
     3   |mmmm:HHHH|
         +---------+
     4   |oooo:oomm|
         +---------+
     5   |ssoo:oooo|
         +---------+
     6   |....:ssss|
         +=========+
     7   |FlexUInt | <-- scale of the fractional seconds
         +---------+
         ...
         +=========+
     N   |FixedUInt| <-- coefficient of the fractional seconds
         +---------+
         ...
----

.Examples of long-form timestamps
[%unbreakable]
[cols="1a,.^1a"]
|===
| Text | Binary

| 1947T
| `F8 05 9B 07`

| 1947-12T
| `F8 07 9B 07 03`

| 1947-12-23T
| `F8 07 9B 07 5F`

| 1947-12-23T11:22:33-00:00
| `F8 0F 9B 07 DF 65 FD 7F 08`

| 1947-12-23T11:22:33+01:15
| `F8 0F 9B 07 DF 65 AD 57 08`

| 1947-12-23T11:22:33.127+01:15
| `F8 13 9B 07 DF 65 AD 57 08 07 7F`
|===


[[text]]
=== Text

[[strings]]
==== Strings

If the high nibble of the opcode is `0x9_`, it represents a string. The low nibble of the opcode
indicates how many UTF-8 bytes follow. Opcode `0x90` represents a string with empty text (`""`).

Strings longer than 15 bytes can be encoded with the `F9` opcode, which takes a <<flexuint, `FlexUInt`>>-encoded length
after the opcode.

`0xEB x05` represents `null.string`.

.Figure {counter:figure}: Encoding of the empty string, `_""_`
[%unbreakable]
----
┌──── Opcode in range 90-9F indicates a string
│┌─── Low nibble 0 indicates that no UTF-8 bytes follow
90
----

.Figure {counter:figure}: Encoding of a 14-byte string
[%unbreakable]
----
┌──── Opcode in range 90-9F indicates a string
│┌─── Low nibble E indicates that 14 UTF-8 bytes follow
││  f  o  u  r  t  e  e  n     b  y  t  e  s
9E 66 6F 75 72 74 65 65 6E 20 62 79 74 65 73
   └──────────────────┬────────────────────┘
                 UTF-8 bytes
----

.Figure {counter:figure}: Encoding of a 24-byte string
[%unbreakable]
----
┌──── Opcode F9 indicates a variable-length string
│  ┌─── Length: FlexUInt 24
│  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     e  n  c  o  d  i  n  g
F9 31 76 61 72 69 61 62 6C 65 20 6C 65 6E 67 74 68 20 65 6E 63 6f 64 69 6E 67
      └────────────────────────────────┬────────────────────────────────────┘
                                  UTF-8 bytes
----

.Figure {counter:figure}: Encoding of `_null.string_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: string
│  │
EB 05
----

[[symbols_with_inline_text]]
==== Symbols With Inline Text

If the high nibble of the opcode is `0xA_`, it represents a symbol whose text follows the opcode. The low nibble of the
opcode indicates how many UTF-8 bytes follow. Opcode `0xA0` represents a symbol with empty text (`''`).

`0xEB x06` represents `null.symbol`.

.Figure {counter:figure}: Encoding of a symbol with empty text (`_''_`)
[%unbreakable]
----
┌──── Opcode in range A0-AF indicates a symbol with inline text
│┌─── Low nibble 0 indicates that no UTF-8 bytes follow
A0
----

.Figure {counter:figure}: Encoding of a symbol with 14 bytes of inline text
[%unbreakable]
----
┌──── Opcode in range A0-AF indicates a symbol with inline text
│┌─── Low nibble E indicates that 14 UTF-8 bytes follow
││  f  o  u  r  t  e  e  n     b  y  t  e  s
AE 66 6F 75 72 74 65 65 6E 20 62 79 74 65 73
   └──────────────────┬────────────────────┘
                 UTF-8 bytes
----

.Figure {counter:figure}: Encoding of a symbol with 24 bytes of inline text
[%unbreakable]
----
┌──── Opcode FA indicates a variable-length symbol with inline text
│  ┌─── Length: FlexUInt 24
│  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     e  n  c  o  d  i  n  g
FA 31 76 61 72 69 61 62 6C 65 20 6C 65 6E 67 74 68 20 65 6E 63 6f 64 69 6E 67
      └────────────────────────────────┬────────────────────────────────────┘
                                  UTF-8 bytes
----

.Figure {counter:figure}: Encoding of `_null.symbol_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: symbol
│  │
EB 06
----

[[symbols_with_symbol_address]]
==== Symbols With a Symbol Address

Symbol values whose text can be found in the local symbol table are encoded using opcodes `0xE1` through `0xE3`:

* `0xE1` represents a symbol whose address in the symbol table (aka its symbol ID) is a 1-byte
<<fixeduint, `FixedUInt`>> that follows the opcode.
* `0xE2` represents a symbol whose address in the symbol table is a 2-byte <<fixeduint, `FixedUInt`>> that follows
the opcode.
* `0xE3` represents a symbol whose address in the symbol table is a <<flexuint,`FlexUInt`>> that follows the opcode.

Writers MUST encode a symbol address in the smallest number of bytes possible. For each opcode above, the symbol
address that is decoded is biased by the number of addresses that can be encoded in fewer bytes.

[cols="^1a,4a,4a"]
|===
|Opcode |Symbol address range |Bias

|`0xE1`
|0 to 255
|0

|`0xE2`
|256 to 65,791
|256

|`0xE3`
|65,792 to infinity
|65,792
|===

[[system_symbols]]
==== System Symbols

System symbols (that is, symbols defined in the system module) can be encoded using the `0xEF` opcode followed by a _negative_ 1-byte `FixedInt`.
(Positive values are used for <<e_expression_invoking_a_macro_from_the_system_module,system macro invocations>>.)

Unlike Ion 1.0, symbols are not required to use the lowest available SID for a given text.
System symbols _MAY_ be encoded using other SIDs, but if an Ion data stream uses imported SIDs for system symbols in encoding directives, then the data may be inaccessible.

.Figure {counter:figure}: Encoding of the system symbol `_$ion_`
[%unbreakable]
----
┌──── Opcode 0xEF indicates a system symbol or macro invocation
│  ┌─── FlexInt -1 indicates system symbol 1
│  │
EF FF
----

// TODO: Add link to "system-module" page.

[[binary_data]]
=== Binary Data

[[blobs]]
==== Blobs

Opcode `FE` indicates a blob of binary data. A `FlexUInt` follows that represents the blob's byte-length.

`0xEB x07` represents `null.blob`.

.Figure {counter:figure}: Encoding of a blob with 24 bytes of data
[%unbreakable]
----
┌──── Opcode FE indicates a blob, FlexUInt length follows
│   ┌─── Length: FlexUInt 24
│   │
FE 31 49 20 61 70 70 6c 61 75 64 20 79 6f 75 72 20 63 75 72 69 6f 73 69 74 79
      └────────────────────────────────┬────────────────────────────────────┘
                            24 bytes of binary data
----

.Figure {counter:figure}: Encoding of `_null.blob_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: blob
│  │
EB 07
----


[[clobs]]
==== Clobs

Opcode `FF` indicates a clob--binary character data of an unspecified encoding. A `FlexUInt` follows that represents
the clob's byte-length.

`0xEB x08` represents `null.clob`.

.Figure {counter:figure}: Encoding of a clob with 24 bytes of data
[%unbreakable]
----
┌──── Opcode FF indicates a clob, FlexUInt length follows
│   ┌─── Length: FlexUInt 24
│   │
FF 31 49 20 61 70 70 6c 61 75 64 20 79 6f 75 72 20 63 75 72 69 6f 73 69 74 79
      └────────────────────────────────┬────────────────────────────────────┘
                            24 bytes of binary data
----

.Figure {counter:figure}: Encoding of `_null.clob_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: clob
│  │
EB 08
----

[[containers]]
=== Containers

Each of the container types (list, s-expression, and struct) has both a length-prefixed encoding and a delimited
encoding.

The length-prefixed encoding places more burden on the writer, but simplifies reading and enables skipping
over uninteresting values in the data stream. In contrast, the delimited encoding is simpler and faster for
writers, but requires the reader to visit each child value in turn to skip over the container.

[[lists]]
==== Lists

===== Length-prefixed encoding

An opcode with a high nibble of `0xB_` indicates a length-prefixed list. The lower nibble of the
opcode indicates how many bytes were used to encode the child values that the list contains.

If the list's encoded byte-length is too large to be encoded in a nibble, writers may use the `0xFB` opcode
to write a variable-length list. The `0xFB` opcode is followed by a
<<flexuint, `FlexUInt`>> that indicates the list's byte length.

`0xEB 0x09` represents `null.list`.

.Figure {counter:figure}: Length-prefixed encoding of an empty list (`_[]_`)
[%unbreakable]
----
┌──── An Opcode in the range 0xB0-0xBF indicates a list.
│┌─── A low nibble of 0 indicates that the child values of this list took zero bytes to encode.
B0
----

.Figure {counter:figure}: Length-prefixed encoding of `_[1, 2, 3]_`
[%unbreakable]
----
┌──── An Opcode in the range 0xB0-0xBF indicates a list.
│┌─── A low nibble of 0 indicates that the child values of this list took zero bytes to encode.
B6 61 01 61 02 61 03
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

.Figure {counter:figure}: Length-prefixed encoding of `_["variable length list"]_`
[%unbreakable]
----
┌──── Opcode 0xFB indicates a variable-length list. A FlexUInt length follows.
│  ┌───── Length: FlexUInt 22
│  │  ┌────── Opcode 0xF9 indicates a variable-length string. A FlexUInt length follows.
│  │  │  ┌─────── Length: FlexUInt 20
│  │  │  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     l  i  s  t
FB 2d F9 29 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 6c 69 73 74
      └─────────────────────────────┬─────────────────────────────────┘
                          Nested string element
----

.Figure {counter:figure}: Encoding of `_null.list_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: list
│  │
EB 09
----

===== Delimited Encoding

Opcode `0xF1` begins a delimited list, while opcode `0xF0` closes the most recently opened delimited container
that has not yet been closed.

.Figure {counter:figure}: Delimited encoding of an empty list (`_[]_`)
[%unbreakable]
----
┌──── Opcode 0xF1 indicates a delimited list
│  ┌─── Opcode 0xF0 indicates the end of the most recently opened container
F1 F0
----

.Figure {counter:figure}: Delimited encoding of `_[1, 2, 3]_`
[%unbreakable]
----
┌──── Opcode 0xF1 indicates a delimited list
│                    ┌─── Opcode 0xF0 indicates the end of
│                    │    the most recently opened container
F1 61 01 61 02 61 03 F0
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

.Figure {counter:figure}: Delimited encoding of `_[1, [2], 3]_`
[%unbreakable]
----
┌──── Opcode 0xF1 indicates a delimited list
│        ┌─── Opcode 0xF1 begins a nested delimited list
│        │        ┌─── Opcode 0xF0 closes the most recently
│        │        │    opened delimited container: the nested list.
│        │        │        ┌─── Opcode 0xF0 closes the most recently opened (and still open)
│        │        │        │    delimited container: the outer list.
│        │        │        │
F1 61 01 F1 61 02 F0 61 03 F0
   └─┬─┘    └─┬─┘    └─┬─┘
     1        2        3
----

[[s_expressions]]
==== S-Expressions

S-expressions use the same encodings as <<lists, lists>>, but with different opcodes.

[cols="^.^1a,4a"]
|===
|Opcode |Encoding

|`0xC0`-`0xCF`
|Length-prefixed S-expression; low nibble of the opcode represents the byte-length.

|`0xFC`
|Variable-length prefixed S-expression; a `FlexUInt` following the opcode represents the byte-length.

|`0xF2`
|Starts a delimited S-expression; `0xF0` closes the most recently opened delimited container.
|===

`0xEB 0x0A` represents `null.sexp`.

.Figure {counter:figure}: Length-prefixed encoding of an empty S-expression (`_()_`)
[%unbreakable]
----
┌──── An Opcode in the range 0xC0-0xCF indicates an S-expression.
│┌─── A low nibble of 0 indicates that the child values of this S-expression took zero bytes to encode.
C0
----

.Figure {counter:figure}: Length-prefixed encoding of `_(1 2 3)_`
[%unbreakable]
----
┌──── An Opcode in the range 0xC0-0xCF indicates an S-expression.
│┌─── A low nibble of 6 indicates that the child values of this S-expression took six bytes to encode.
C6 61 01 61 02 61 03
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

.Figure {counter:figure}: Length-prefixed encoding of `_("variable length sexp")_`
[%unbreakable]
----
┌──── Opcode 0xFC indicates a variable-length sexp. A FlexUInt length follows.
│  ┌───── Length: FlexUInt 22
│  │  ┌────── Opcode 0xF9 indicates a variable-length string. A FlexUInt length follows.
│  │  │  ┌─────── Length: FlexUInt 20
│  │  │  │   v  a  r  i  a  b  l  e     l  e  n  g  t  h     s  e  x  p
FC 2D F9 29 76 61 72 69 61 62 6C 65 20 6C 65 6E 67 74 68 20 73 65 78 70
      └─────────────────────────────┬─────────────────────────────────┘
                          Nested string element
----

.Figure {counter:figure}: Delimited encoding of an empty S-expression (`_()_`)
[%unbreakable]
----
┌──── Opcode 0xF2 indicates a delimited S-expression
│  ┌─── Opcode 0xF0 indicates the end of the most recently opened container
F2 F0
----

.Figure {counter:figure}: Delimited encoding of `_(1 2 3)_`
[%unbreakable]
----
┌──── Opcode 0xF2 indicates a delimited S-expression
│                    ┌─── Opcode 0xF0 indicates the end of
│                    │    the most recently opened container
F2 61 01 61 02 61 03 F0
   └─┬─┘ └─┬─┘ └─┬─┘
     1     2     3
----

.Figure {counter:figure}: Delimited encoding of `_(1 (2) 3)_`
[%unbreakable]
----
┌──── Opcode 0xF2 indicates a delimited S-expression
│        ┌─── Opcode 0xF2 begins a nested delimited S-expression
│        │        ┌─── Opcode 0xF0 closes the most recently
│        │        │    opened delimited container: the nested S-expression.
│        │        │        ┌─── Opcode 0xF0 closes the most recently opened (and still open)
│        │        │        │    delimited container: the outer S-expression.
│        │        │        │
F2 61 01 F2 61 02 F0 61 03 F0
   └─┬─┘    └─┬─┘    └─┬─┘
     1        2        3
----

.Figure {counter:figure}: Encoding of `_null.sexp_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: sexp
│  │
EB 0A
----

[[structs]]
==== Structs

Structs have 3 available encodings:

. <<structs_with_symbol_address_field_names, Structs with symbol address field names>>
. <<structs_with_flexsym_field_names, Structs with `FlexSym` field names>>
. <<delimited_structs, Delimited structs with `FlexSym` field names>>

`0xEB 0x0B` represents `null.struct`.

.Figure {counter:figure}: Encoding of `_null.struct_`
[%unbreakable]
----
┌──── Opcode 0xEB indicates a typed null; a byte follows specifying the type
│  ┌─── Null type: struct
│  │
EB 0B
----

[[structs_with_symbol_address_field_names]]
===== Structs With Symbol Address Field Names

An opcode with a high nibble of `0xD_` indicates a struct with symbol address field names (which is similar to the
link:https://amazon-ion.github.io/ion-docs/docs/binary.html#0xd-struct[only available encoding of structs in Ion 1.0].
The lower nibble of the opcode indicates how many bytes were used to encode all of its nested `(field name, value)` pairs.

If the struct's encoded byte-length is too large to be encoded in a nibble, writers may use the `0xFD` opcode
to write a variable-length struct with symbol address field names. The `0xFD` opcode is followed by a
<<flexuint, `FlexUInt`>> that indicates the byte length.

Each field in the struct is encoded as a <<flexuint, `FlexUInt`>> representing the address of the field name's
text in the symbol table, followed by an opcode-prefixed value.

The symbol address `$0` cannot be encoded in this format because the `FlexUInt` `0` in the field name position is reserved for <<structs_with_flexsym_field_names, switching the struct to `FlexSym` field names>>.

.Figure {counter:figure}: Length-prefixed encoding of an empty struct (`_{}_`)
[%unbreakable]
----
┌──── An opcode in the range 0xD0-0xDF indicates a struct with symbol address field names
│┌─── A lower nibble of 0 indicates that the struct's fields took zero bytes to encode
D0
----

.Figure {counter:figure}: Length-prefixed encoding of `_{$10: 1, $11: 2}_`
[%unbreakable]
----
┌──── An opcode in the range 0xD0-0xDF indicates a struct with symbol address field names
│  ┌─── Field name: FlexUInt 10 ($10)
│  │        ┌─── Field name: FlexUInt 11 ($11)
│  │        │
D6 15 61 01 17 61 02
      └─┬─┘    └─┬─┘
        1        2
----

.Figure {counter:figure}: Length-prefixed encoding of `_{$10: "variable length struct"}_`
[%unbreakable]
----
 ┌───────────── Opcode `FD` indicates a variable length struct with symbol address field names
 │  ┌────────── Length: FlexUInt 25
 │  │  ┌─────── Field name: FlexUInt 10 ($10)
 │  │  │  ┌──── Opcode `F9` indicates a variable length string
 │  │  │  │  ┌─ FlexUInt: 22 the string is 22 bytes long
 │  │  │  │  │  v  a  r  i  a  b  l  e     l  e  n  g  t  h     s  t  r  u  c  t
FD 33 15 F9 2D 76 61 72 69 61 62 6c 65 20 6c 65 6e 67 74 68 20 73 74 72 75 63 74
               └─────────────────────────────┬─────────────────────────────────┘
                                        UTF-8 bytes
----

[[structs_with_flexsym_field_names]]
===== Structs With `FlexSym` Field Names

NOTE: This encoding is very similar to <<structs_with_symbol_address_field_names, structs with symbol address
field names>>, but allows writers to choose between representing each field name as a symbol address
(for example: `$10`) or as inline UTF-8 bytes (for example: `"foo"`). This encoding is potentially less
dense, but offers writers significant flexibility over whether and when field names are added to the
symbol table.

All length-prefixed structs begin as structs with symbol address field names.
However, they can be switched to use `FlexSym` field names at any time by emitting the FlexUInt 0 (the byte `0x01`) in the field name position. Once a struct has been switched to the `FlexSym` field name encoding, it cannot be switch back.

Each field in the struct is encoded as a  <<flexsym, `FlexSym`>> field name, followed by an opcode-prefixed value.

.Figure {counter:figure}: Length-prefixed encoding of `_{"foo": 1, $11: 2}_`
[%unbreakable]
----
┌─── Opcode with high nibble `D` indicates a struct
│┌── Length: 10
││ ┌── FlexUInt 0 in the field name position indicates that the struct is switching to FlexSym mode
││ │  ┌─ FlexSym -3     ┌─ FlexSym: 11 ($11)
││ │  │   f  o  o       │
DA 01 FD 66 6F 6F 61 01 17 61 02
         └──┬───┘ └─┬─┘    └─┬─┘
         3 UTF-8    1        2
          bytes
----

.Figure {counter:figure}: Length-prefixed encoding of `_{$11: 1, "foo": 2}_`
[%unbreakable]
----
┌─── Opcode with high nibble `D` indicates a struct
│┌── Length: 10
││ ┌─ FlexSym: 11 ($11)
││ │        ┌── FlexUInt 0 in the field name position indicates that the struct is switching to FlexSym mode
││ │        │  ┌─ FlexSym -3
││ │        │  │   f  o  o
DA 17 61 01 01 FD 66 6F 6F 61 02
      └─┬─┘       └──┬───┘ └─┬─┘
        1         3 UTF-8    2
                   bytes
----

.Figure {counter:figure}: Length-prefixed encoding of `_{$0: 1}_`
[%unbreakable]
----
┌─── Opcode with high nibble `D` indicates a struct
│┌── Length: 5
││ ┌── FlexUInt 0 in the field name position indicates that the struct is switching to FlexSym mode
││ │  ┌── FlexSym "escape"
││ │  │
││ │  │
D5 01 01 A0 61 01
      └─┬─┘ └─┬─┘
       $0     1
----

[sidebar]
TODO: Demonstrate splicing macro values into the struct via FlexSym escape code `0x01`.

[[delimited_structs]]
===== Delimited Structs

Opcode `0xF3` indicates the beginning of a delimited struct with <<flexsym, `FlexSym`>> field names.

Unlike lists and S-expressions, structs cannot use opcode `0xF0` by itself to indicate the end of the delimited
container. This is because `0xF0` is a valid `FlexSym` (a symbol with 16 bytes of inline text). To close the delimited
struct, the writer emits a `0x01` byte (a `FlexSym` escape) followed by the opcode `0xF0`.

NOTE: While length-prefixed structs can choose between <<structs_with_symbol_address_field_names, structs with
symbol address field names>> and <<structs_with_flexsym_field_names, structs with `FlexSym` field names>>,
delimited structs always use `FlexSym`-encoded field names.

.Figure {counter:figure}: Delimited encoding of the empty struct (`_{}_`)
[%unbreakable]
----
┌─── Opcode 0xF3 indicates the beginning of a delimited struct with `FlexSym` field names.
│  ┌─── FlexSym escape code 0 (0x01): an opcode follows
│  │  ┌─── Opcode 0xF0 indicates the end of the most
│  │  │    recently opened delimited container
F3 01 F0
----

.Figure {counter:figure}: Delimited encoding of `_{"foo": 1, $11: 2}_`
[%unbreakable]
----
┌─── Opcode 0xF3 indicates the beginning of a delimited struct with `FlexSym` field names.
│
│  ┌─ FlexSym -3     ┌─ FlexSym: 11 ($11)
│  │                 │        ┌─── FlexSym escape code 0 (0x01): an opcode follows
│  │                 │        │  ┌─── Opcode 0xF0 indicates the end of the most
│  │   f  o  o       │        │  │    recently opened delimited container
F3 FD 66 6F 6F 61 01 17 61 02 01 F0
      └──┬───┘ └─┬─┘    └─┬─┘
      3 UTF-8    1        2
       bytes
----

[[nulls]]
=== Nulls

The opcode `0xEA` indicates an untyped null (that is: `null`, or its alias `null.null`).

The opcode `0xEB` indicates a typed null; a byte follows whose value represents an offset into the following table:

[cols="^1a,4a"]
|===
|Byte |Type

|`0x00`
|`null.bool`

|`0x01`
|`null.int`

|`0x02`
|`null.float`

|`0x03`
|`null.decimal`

|`0x04`
|`null.timestamp`

|`0x05`
|`null.string`

|`0x06`
|`null.symbol`

|`0x07`
|`null.blob`

|`0x08`
|`null.clob`

|`0x09`
|`null.list`

|`0x0A`
|`null.sexp`

|`0x0B`
|`null.struct`
|===

All other byte values are reserved for future use.

NOTE: Future versions of Ion may decide to generalize this into a "constants" table.

.Figure {counter:figure}: Encoding of `_null_`
[%unbreakable]
----
┌──── The opcode `0xEA` represents a null (null.null)
EA
----

.Figure {counter:figure}: Encoding of `_null.string_`
[%unbreakable]
----
┌──── The opcode `0xEB` indicates a typed null; a byte indicating the type follows
│  ┌──── Byte 0x05 indicates the type `string`
EB 05
----

[[annotations]]
=== Annotations

Annotations can be encoded either <<annotations_with_symbol_addresses, as symbol addresses>>
or <<annotations_with_flexsym_text, as ``FlexSym``s>>. In both encodings, the annotations sequence appears
just before the value that it decorates.

It is illegal for an annotations sequence to appear before any of the following:

* Another annotations sequence
* The end of the stream
* A <<nops, `NOP`>>
* An <<e_expression_with_the_address_in_the_opcode, E-expression>> (that is: a macro invocation). To add annotations
to the expansion of an E-expression, see the `annotate` macro. (TODO: Link)

[[annotations_with_symbol_addresses]]
=== Annotations With Symbol Addresses
Opcodes `0xE4` through `0xE6` indicate one or more annotations encoded as symbol addresses. If the opcode is:

* `0xE4`, a single <<flexuint, `FlexUInt`>>-encoded symbol address follows.
* `0xE5`, two <<flexuint, `FlexUInt`>>-encoded symbol addresses follow.
* `0xE6`, a <<flexuint, `FlexUInt`>> follows that represents the number of bytes needed to encode
the annotations sequence, which can be made up of any number of `FlexUInt` symbol addresses.

.Figure {counter:figure}: Encoding of `_$10::false_`
[%unbreakable]
----
┌──── The opcode `0xE4` indicates a single annotation encoded as a symbol address follows
│  ┌──── Annotation with symbol address: FlexUInt 10
E4 15 6F
      └── The annotated value: `false`
----

.Figure {counter:figure}: Encoding of `_$10::$11::false_`
[%unbreakable]
----
┌──── The opcode `0xE5` indicates that two annotations encoded as symbol addresses follow
│  ┌──── Annotation with symbol address: FlexUInt 10 ($10)
│  │  ┌──── Annotation with symbol address: FlexUInt 11 ($11)
E5 15 17 6F
         └── The annotated value: `false`
----

.Figure {counter:figure}: Encoding of `_$10::$11::$12::false_`
[%unbreakable]
----
┌──── The opcode `0xE6` indicates a variable-length sequence of symbol address annotations;
│     a FlexUInt follows representing the length of the sequence.
│   ┌──── Annotations sequence length: FlexUInt 3 with symbol address: FlexUInt 10 ($10)
│   │  ┌──── Annotation with symbol address: FlexUInt 10 ($10)
│   │  │  ┌──── Annotation with symbol address: FlexUInt 11 ($11)
│   │  │  │  ┌──── Annotation with symbol address: FlexUInt 12 ($12)
E5 07 15 17 19 6F
               └── The annotated value: `false`
----

[[annotations_with_flexsym_text]]
=== Annotations With `FlexSym` Text

Opcodes `0xE7` through `0xE9` indicate one or more annotations encoded as <<flexsym, `FlexSym`>>s.

If the opcode is:

* `0xE7`, a single `FlexSym`-encoded symbol follows.
* `0xE8`, two `FlexSym`-encoded symbols follow.
* `0xE9`, a `FlexUInt` follows that represents the byte length of the annotations sequence, which is
made up of any number of annotations encoded as ``FlexSym``s.

While this encoding is more flexible than <<annotations_with_symbol_addresses, annotations with
symbol addresses>>, it can be slightly less compact when all the annotations are encoded as symbol
addresses.

.Figure {counter:figure}: Encoding of `_$10::false_`
[%unbreakable]
----
┌──── The opcode `0xE7` indicates a single annotation encoded as a FlexSym follows
│  ┌──── Annotation with symbol address: FlexSym 10 ($10)
E7 15 6F
      └── The annotated value: `false`
----

.Figure {counter:figure}: Encoding of `_foo::false_`
[%unbreakable]
----
┌──── The opcode `0xE7` indicates a single annotation encoded as a FlexSym follows
│  ┌──── Annotation: FlexSym -3; 3 bytes of UTF-8 text follow
│  │   f  o  o
E7 FD 66 6F 6F 6F
      └──┬───┘ └── The annotated value: `false`
      3 UTF-8
       bytes
----

Note that `FlexSym` annotation sequences can switch between symbol address and inline text
on a per-annotation basis.

.Figure {counter:figure}: Encoding of `_$10::foo::false_`
[%unbreakable]
----
┌──── The opcode `0xE8` indicates two annotations encoded as FlexSyms follow
│  ┌──── Annotation: FlexSym 10 ($10)
│  │  ┌──── Annotation: FlexSym -3; 3 bytes of UTF-8 text follow
│  │  │   f  o  o
E8 15 FD 66 6F 6F 6F
         └──┬───┘ └── The annotated value: `false`
         3 UTF-8
          bytes
----

.Figure {counter:figure}: Encoding of `_$10::foo::$11::false_`
[%unbreakable]
----
┌──── The opcode `0xE9` indicates a variable-length sequence of FlexSym-encoded annotations
│  ┌──── Length: FlexUInt 6
│  │  ┌──── Annotation: FlexSym 10 ($10)
│  │  │  ┌──── Annotation: FlexSym -3; 3 bytes of UTF-8 text follow
│  │  │  │           ┌──── Annotation: FlexSym 11 ($11)
│  │  │  │   f  o  o │
E9 0D 15 FD 66 6F 6F 17 6F
            └──┬───┘    └── The annotated value: `false`
            3 UTF-8
             bytes
----

[[nops]]
=== ``NOP``s

A `NOP` (short for "no-operation") is the binary equivalent of whitespace. `NOP` bytes have no meaning,
but can be used as padding to achieve a desired alignment.

An opcode of `0xEC` indicates a single-byte `NOP` pad. An opcode of `0xED` indicates that a
<<flexuint, `FlexUInt`>> follows that represents the number of additional bytes to skip.

It is legal for a `NOP` to appear anywhere that a value can be encoded. It is not legal for a `NOP` to appear in
annotation sequences or struct field names. If a `NOP` appears in place of a struct field _value_, then the associated
field name is ignored; the `NOP` is immediately followed by the next field name, if any.

.Figure {counter:figure}: Encoding of a 1-byte `_NOP_`
[%unbreakable]
----
┌──── The opcode `0xEC` represents a 1-byte NOP pad
│
EC
----

.Figure {counter:figure}: Encoding of a 4-byte `_NOP_`
[%unbreakable]
----
┌──── The opcode `0xED` represents a variable-length NOP pad; a FlexUInt length follows
│  ┌──── Length: FlexUInt 2; two more bytes of NOP follow
│  │
ED 05 93 C6
      └─┬─┘
NOP bytes, values ignored
----

[[e_expression_arguments]]
=== E-expression Arguments

The binary encoding of E-expressions (aka macro invocations) starts with the address of the macro to expand. The address
can be encoded as <<e_expression_with_the_address_in_the_opcode, part of the opcode>>, as
<<e_expression_with_the_address_as_a_trailing_fixeduint, a `FixedUInt` that follows the opcode>>, or as
<<e_expression_with_the_address_as_a_trailing_flexuint, a `FlexUInt` that follows the opcode>>.

The encoding of the E-expression's arguments depends on their respective types. Argument types can be classified as
belonging to one of two categories: <<tagged_encodings, _tagged encodings_>> and
<<tagless_encodings, _tagless encodings_>>.

[[tagged_encodings]]
==== Tagged Encodings

_Tagged types_ are argument types whose encoding begins with an <<opcodes, opcode>>, sometimes informally called a 'tag'.
These include the <<core_types, core types>> and the <<abstract_types, abstract types>>.

[[core_types]]
===== Core types

The _core types_ are the 13 types in the Ion data model:

`null`
| `bool`
| `int`
| `float`
| `decimal`
| `timestamp`
| `string`
| `symbol`
| `blob`
| `clob`
| `list`
| `sexp`
| `struct`

[[abstract_types]]
===== Abstract types

The _abstract types_ are unions of two or more of the <<core_types, core types>>.

[cols="^.^1a, 6a"]
|===
|Abstract type |Included Ion types

|`any`
|All core Ion types

|`number`
|`int`, `float`, `decimal`

|`exact`
|`int`, `decimal`

|`text`
|`string`, `symbol`

|`lob`
|`blob`, `clob`

|`sequence`
|`list`, `sexp`
|===

===== Tagged E-expression Argument Encoding

When a macro parameter has a tagged type, the encoding of that parameter's corresponding argument in an E-expression
is identical to how it would be encoded anywhere else in an Ion stream: it has a leading <<opcodes, opcode>> that
dictates how many bytes follow and how they should be interpreted. This is very flexible, but makes it possible
for writers to encode values that conflict with the parameter's declared type. Because of this, the macro expander will
read the argument and then check its type against the parameter's declared type. If it does not match, the macro
expander must raise an error.

Macro `foo` (defined below) is used in this section's subsequent examples to demonstrate the encoding of tagged-type
arguments.

.Figure {counter:figure}: Definition of example macro `_foo_` at address 0
[%unbreakable]
----
(macro
    foo           // Macro name
    (number::x!)  // Parameters
    /*...*/       // Template (elided)
)
----

.Figure {counter:figure}: Encoding of E-expression `_(:foo 3.14e0)_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a tagged number as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0x6B indicates a 2-byte float; an IEEE-754 half-precision float follows
│  │
00 6B 47 42
      └─┬─┘
      3.14e0

// The macro expander confirms that `3.14e0` (a `float`) matches the expected type: `number`.
----

.Figure {counter:figure}: Encoding of E-expression `_(:foo 9)_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a tagged number as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0x61 indicates a 1-byte integer. A 1-byte FixedInt follows.
│  │  ┌──── A 1-byte FixedInt: 9
00 61 09

// The macro expander confirms that `9` (an `int`) matches the expected type: `number`.
----

.Figure {counter:figure}: Encoding of E-expression `_(:foo $10::9)_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a tagged number as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0xE4 indicates a single annotation with symbol address. A FlexUInt follows.
│  │  ┌──── Symbol address: FlexUInt 10 ($10); an opcode for the annotated value follows.
│  │  │  ┌──── Opcode 0x61 indicates a 1-byte integer
│  │  │  │   ┌──── 1-byte FixedInt 9
00 E4 15 61 09

// The macro expander confirms that `$10::9` (an annotated `int`) matches the expected type: `number`.
----

.Figure {counter:figure}: Encoding of E-expression `_(:foo null.int)_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a tagged number as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0xEB indicates a typed null. A 1-byte FixedUInt follows indicating the type.
│  │  ┌──── Null type: FixedUInt: 1; integer
00 EB 01

// The macro expander confirms that `null.int` matches the expected type: `number`.
----

.Figure {counter:figure}: Encoding of E-expression `_(:foo null)_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a tagged number as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0xEA represents an untyped null (aka `null.null`)
00 EA

// The macro expander confirms that `null` matches the expected type: `number`
----

.Figure {counter:figure}: Encoding of E-expression `_(:foo (:bar))_`
[%unbreakable]
----
// A second macro definition at address 1
(macro
    bar // Macro name
    ()  // Parameters
    5   // Template; invocations of `bar` always expand to `5`.
)

┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a tagged int as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0x01 is less than 0x40, so it is an E-expression invoking the macro
│  │     at address 1: `bar`. `bar` takes no parameters, so no bytes follow.
00 01

// The macro expander confirms that the expansion of `(:bar)` (that is: `5`) matches
// the expected type: `number`.
----

.Figure {counter:figure}: Encoding of illegal E-expression `_(:foo "hello")_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0, `foo`. `foo` takes a tagged int as a parameter (`x`), so an opcode follows.
│  ┌──── Opcode 0x95 indicates a 5-byte string. 5 UTF-8 bytes follow.
│  │  h  e  l  l  o
00 95 68 65 6C 6C 6F
      └──────┬─────┘
        UTF-8 bytes

// ERROR: Expected a `number` for `foo` parameter `x`, but found `string`
----

[[tagless_encodings]]
==== Tagless Encodings

In contrast to <<tagged_encodings, tagged encodings>>, _tagless encodings_ do not begin with an opcode. This means
that they are potentially more compact than a tagged type, but are also less flexible. Because tagless encodings
do not have an opcode, they cannot represent E-expressions, annotation sequences, or `null` values of any kind.

Tagless types include the <<primitive_encodings, primitive types>> and <<macro_shapes, macro shapes>>.

[[primitive_encodings]]
===== Primitive Types

Primitive types are self-delineating, either by having a statically known size in bytes or by including length
information in their encoding.

Primitive types include:

[cols="^.^1a,^.^2a,^.^1a,^.^4a"]
|===
|Ion type |Primitive type |Size in bytes| Encoding

.10+|`int`
|`uint8`
|1
.4+| <<fixeduint, `FixedUInt`>>

|`uint16`
|2

|`uint32`
|4

|`uint64`
|8

|`compact_uint`
|variable
|<<flexuint, `FlexUInt`>>

|`int8`
|1
.4+| <<fixedint, `FixedInt`>>

|`int16`
|2

|`int32`
|4

|`int64`
|8

|`compact_int`
|variable
|<<flexint, `FlexInt`>>

.3+|`float`
|`float16`
|2
|link:https://en.wikipedia.org/wiki/Half-precision_floating-point_format[IEEE-754 half-precision floating point format (little-endian)]

|`float32`
|4
|link:https://en.wikipedia.org/wiki/Single-precision_floating-point_format[IEEE-754 single-precision floating point format (little-endian)]

|`float64`
|8
|link:https://en.wikipedia.org/wiki/Double-precision_floating-point_format[IEEE-754 double-precision floating point format (little-endian)]

|`symbol`
|`compact_symbol`
|variable
|<<flexsym, `FlexSym`>>
|===

[sidebar]
****
TODO:

* Finalize names for primitive types. (`compact_`? `plain_`?)
* Do we need a `compact_string` encoding? It saves a byte for string lengths >16 and <128.
* Do we need other int sizes? `int24`? `int40`?
****

[[macro_shapes]]
===== Macro Shapes

The term _macro shape_ describes a macro that is being used as the encoding of an E-expression argument. They are
considered "shapes" rather than types because while their encoding is always statically known, the types of data
produced by their expansion is not. A single macro can produce streams of varying length and containing values of
different Ion types depending on the arguments provided in the invocation.

See the link:macros-by-example.adoc#eg:macro_shapes[Macro Shapes] section of _Macros by Example_ for more information.

=== Encoding E-expressions With Multiple Arguments

E-expression arguments corresponding to each parameter are encoded one after the other moving from left to right.

.Figure {counter:figure}: Definition of macro `_foo_` at address `_0_`
[%unbreakable]
----
(macro foo             // Macro name
  (                    // Parameters
    string::a
    compact_symbol::b
    uint16::c
  )
  /* ... */            // Body (elided)
)
----

.Figure {counter:figure}: Encoding of E-expression for macro with multiple parameters: `_(:0 "hello" baz 512)_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0, `foo`. `foo`'s first parameter is a string, so an opcode follows.
│
│  ┌──── Opcode 0x95 indicates a 5-byte string. 5 UTF-8 bytes follow.
│  │
│  │                 ┌──── `foo`'s second parameter is a compact_symbol, so a `FlexSym` follows.
│  │                 │     FlexSym -3: 3 bytes of UTF-8 text follow.
│  │                 │
│  │                 │           ┌──── `foo`'s third parameter is a uint16, so a 2-byte
│  │                 │           │     2-byte `FixedUInt` follows.
│  │                 │           │     FixedUInt: 512
│  │  h  e  l  l  o  │   b  a  z │
00 95 68 65 6C 6C 6F FD 62 61 7A 00 20
      └──────┬─────┘    └───┬──┘
        UTF-8 bytes    UTF-8 bytes
----

[[argument_encoding_bitmap]]
=== Argument Encoding Bitmap (AEB)

The examples in previous sections have only shown how to encode invocations of macros which have either no parameters
at all (aka _constants_) or whose parameters all have
link:macros-by-example.adoc#exactly_one[a cardinality of exactly-one].

If a macro has any parameters with a cardinality of zero-or-one (`?`), zero-or-more (`*`), or one-or-more (`+`),
then E-expressions invoking that macro will begin with an _argument encoding bitmap_ (AEB).
An AEB is a series of bits that correspond to a macro parameter and communicate additional
information about how the arguments corresponding to that parameter have been encoded in the current E-expression.
In particular, the AEB indicates whether a parameter that accepts `(:void)` has any arguments at all, and how a
grouped parameter's arguments have been delimited.

The number of bits allotted to each parameter is determined by its cardinality, as shown in the table below; each
parameter can have 0, 1, or 2 bits.

[cols="^.^2a,^.^2a,^.^2a,^.^1a,^.^1a,.^6a"]
|===
|Grouping Mode|Cardinality|Example parameter signature|Number of bits|Bit(s) value|Encoding

.6+|Ungrouped
|Exactly-one
|`(x int!)`
|0
|_n/a_
|One expression

.2+|Zero-or-one
.2+|`(x int?)`
.4+|1
|`0`
<|No expression; equivalent to `(:void)`

|`1`
<|One expression

.2+|Zero-or-more
.2+|`(x int*)`
|`0`
<|No expression; equivalent to `(:void)`

|`1`
<|One expression

|One-or-more
|`(x int+)`
|0
|_n/a_
<|One expression

.8+|Grouped
.4+|Zero-or-more
.4+|`(x [int])` +
`(x int\...)`
.8+|2
|`00`
|No expression; equivalent to `(:void)`

|`01`
<|One expression

|`10`
<|Length-prefixed expression group

|`11`
<|Delimited expression group

.4+|One-or-more
.4+|`(x [int]+)` +
`(x int\...+)`
|`00`
<|_Illegal._ One-or-more forbids `(:void)`.

|`01`
<|One expression

|`10`
<|<<length_prefixed_expression_groups, Length-prefixed expression group>>

|`11`
<|<<delimited_expression_groups, Delimited expression group>>

|===

The total number of bits in the AEB can be calculated by analyzing the signature of the macro being invoked.
If the macro has no parameters or all of its parameters have a cardinality of either exactly-one or one-or-more,
no bits are required; the AEB will be omitted altogether.
If the macro has many parameters with a cardinality other than exactly-one, it is possible for the AEB to require more
than one byte to encode; in such cases, the bytes are written in little-endian order.
AEB bytes can contain unused bits.

Bits are assigned to the parameters in a macro's signature from left to right.
Bits are assigned from least significant to most significant (commonly: right-to-left).

[cols="<.^8a,^.^3a,^.^2a"]
|===
|Example parameter sequence |Bit assignments |Total bits

| `()`
|_No AEB_
|0

| `\((a int!) (b string!) (c float!))`
|_No AEB_
|0

| `\((a int!) (b string!) (c float?))`
| `-------c`
| 1

| `\((a int!) (b string?) (c float!))`
| `-------b`
| 1

| `\((a int!) (b string*) (c float?))`
| `------cb`
| 2

| `\((a int*) (b string!) (c [float]))`
| `-----cca`
| 3

| `\((a int*) (b [string]) (c [float]))`
| `---ccbba`
| 5

| `\((a [int]) (b [string]) (c [float]+))`
| `--ccbbaa`
| 6

| `\((a int*) (b [string]) (c [float]) (d [bool]) (e blob...))`
| `eddccbba` +
`-------e`
| 9

|===

[#expression_groups]
=== Expression Groups

Grouped parameters can be encoded using either a <<length_prefixed_expression_groups, length-prefixed>> or
<<delimited_expression_groups, delimited>> expression group encoding.

The example encodings in the following sections refer to this macro definition:

.Figure {counter:figure}: Definition of macro `_foo_` at address `_0_`
[%unbreakable]
----
(macro
    foo          // Macro name
    (int::x*)    // Parameters; `x` is a grouped parameter
    /*...*/      // Body (elided)
)
----

[#length_prefixed_expression_groups]
==== Length-prefixed Expression Groups

If a grouped parameter's <<argument_encoding_bitmap, AEB bits>> are `0b10`, then the argument expressions belonging
to that parameter will be prefixed by a `FlexUInt` indicating the number of bytes used to encode them.

.Figure {counter:figure}: Length-prefixed encoding of `_(:foo [1, 2, 3])_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a group of int expressions as a parameter (`x`),
│     so an argument encoding bitmap (AEB) follows.
│  ┌──── AEB: 0b0000_0010; the arguments for grouped parameter `x` have been encoded
│  │     as a length-prefixed expression group. A FlexUInt length prefix follows.
│  │  ┌──── FlexUInt: 6; the next 6 bytes are an `int` expression group.
│  │  │
00 02 0D 61 01 61 02 61 03
         └─┬─┘ └─┬─┘ └─┬─┘
           1     2     3
----

[#delimited_expression_groups]
==== Delimited Expression Groups

If a grouped parameter's <<argument_encoding_bitmap, AEB bits>> are `0b11`, then the argument expressions belonging
to that parameter will be encoded in a delimited sequence.
Delimited sequences are encoded differently for <<tagged_encodings,tagged types>> and
<<tagless_encodings, tagless types>>.

===== Delimited Tagged Expression Groups

Tagged type encodings begin with an <<opcodes, opcode>>; a delimited sequence of tagged arguments is terminated by
the closing delimiter opcode, `0xF0`.

.Figure {counter:figure}: Delimited encoding of `_(:foo [1, 2, 3])_`
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a group of int expressions as a parameter (`x`),
│     so an argument encoding bitmap (AEB) follows.
│  ┌──── AEB: 0b0000_0011; the arguments for grouped parameter `x` have been encoded
│  │     as a delimited expression group. A series of tagged `int` expressions follow.
│  │                    ┌──── Opcode 0xF0 ends the expression group.
│  │                    │
00 03 61 01 61 02 61 03 F0
      └─┬─┘ └─┬─┘ └─┬─┘
        1     2     3
----

===== Delimited Tagless Expression Groups

Tagless type encodings do not have an opcode, and so cannot use the closing delimiter opcode--`0xF0` is a valid first
byte for many tagless encodings.

Instead, tagless expressions are grouped into 'pages', each of which is prefixed by a <<flexuint, `FlexUInt`>>
representing a count (not a byte-length) of the expressions that follow. If a prefix has a count of zero, that marks
the end of the sequence of pages.

.Figure {counter:figure}: Definition of macro `_compact_foo_` at address `_1_`
[%unbreakable]
----
(macro
    compact_foo          // Macro name
    (compact_int::x*)    // Parameters; `x` is a grouped parameter
    /*...*/              // Body (elided)
)
----

.Figure {counter:figure}: Delimited encoding of `_(:compact_foo [1, 2, 3])_` using a single page
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a group of int expressions as a parameter (`x`),
│     so an argument encoding bitmap (AEB) follows.
│  ┌──── AEB: 0b0000_0011; the arguments for grouped parameter `x` have been encoded
│  │     as a delimited expression group. Count-prefixed pages of `compact_int`
│  │     expressions follow.
│  │   ┌──── Count prefix: FlexUInt 3; 3 `compact_int`s follow.
│  │   │          ┌──── Count prefix: FlexUInt 0; no more pages follow.
│  │   │          │
00 03 07 03 05 07 01
         └──┬───┘
         First page: 1, 2, 3
----

.Figure {counter:figure}: Delimited encoding of `_(:compact_foo [1, 2, 3])_` using two pages
[%unbreakable]
----
┌──── The opcode is less than 0x40, so it is an E-expression invoking the macro at
│     address 0: `foo`. `foo` takes a group of int expressions as a parameter (`x`),
│     so an argument encoding bitmap (AEB) follows.
│  ┌──── AEB: 0b0000_0011; the arguments for grouped parameter `x` have been encoded
│  │     as a delimited expression group. Count-prefixed pages of `compact_int`
│  │     expressions follow.
│  │   ┌──── Count prefix: FlexUInt 2; 2 `compact_int`s follow.
│  │   │        ┌──── Count prefix: FlexUInt 1; a single `compact_int` follows.
│  │   │        │    ┌──── Count prefix: FlexUInt 0; no more pages follow.
│  │   │        │    │
00 03 05 03 05 03 07 01
         └─┬─┘    └─ Second page: 3
           │
         First page: 1, 2
----
